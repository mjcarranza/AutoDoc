{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst util_1 = require(\"./util\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nconst id = x => {\n  return x;\n};\n\nfunction toProto3JSON(obj, options) {\n  const objType = obj.$type;\n\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n\n  objType.resolveAll();\n  const typeName = (0, util_1.getFullyQualifiedTypeName)(objType); // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n\n  if (typeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyToProto3JSON)(obj, options);\n  }\n\n  if (typeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Struct') {\n    return (0, value_1.googleProtobufStructToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.ListValue') {\n    return (0, value_1.googleProtobufListValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Duration') {\n    return (0, duration_1.googleProtobufDurationToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Timestamp') {\n    return (0, timestamp_1.googleProtobufTimestampToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.FieldMask') {\n    return (0, fieldmask_1.googleProtobufFieldMaskToProto3JSON)(obj);\n  }\n\n  if (util_1.wrapperTypes.has(typeName)) {\n    return (0, wrappers_1.wrapperToProto3JSON)(obj);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const field = objType.fields[key];\n    const fieldResolvedType = field.resolvedType;\n    const fieldFullyQualifiedTypeName = fieldResolvedType ? (0, util_1.getFullyQualifiedTypeName)(fieldResolvedType) : null;\n\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length === 0) {\n        // ignore repeated fields with no values\n        continue;\n      } // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n\n\n      result[key] = value.map(fieldResolvedType ? element => {\n        return toProto3JSON(element, options);\n      } : id);\n      continue;\n    }\n\n    if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue, options) : mapValue;\n      }\n\n      result[key] = map;\n      continue;\n    }\n\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      if (options === null || options === void 0 ? void 0 : options.numericEnums) {\n        result[key] = (0, enum_1.resolveEnumValueToNumber)(fieldResolvedType, value);\n      } else {\n        result[key] = (0, enum_1.resolveEnumValueToString)(fieldResolvedType, value);\n      }\n\n      continue;\n    }\n\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value, options);\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      if (typeof value === 'number' && !Number.isFinite(value)) {\n        result[key] = value.toString();\n        continue;\n      }\n\n      result[key] = value;\n      continue;\n    }\n\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = (0, bytes_1.bytesToProto3JSON)(value);\n      continue;\n    } // The remaining case is Long, everything else is an internal error\n\n\n    (0, util_1.assert)(value.constructor.name === 'Long', `toProto3JSON: don't know how to convert field ${key} with value ${value}`);\n    result[key] = value.toString();\n    continue;\n  }\n\n  return result;\n}\n\nexports.toProto3JSON = toProto3JSON;","map":{"version":3,"names":["Object","defineProperty","exports","value","toProto3JSON","any_1","require","bytes_1","util_1","enum_1","value_1","duration_1","timestamp_1","wrappers_1","fieldmask_1","id","x","obj","options","objType","$type","Error","resolveAll","typeName","getFullyQualifiedTypeName","googleProtobufAnyToProto3JSON","googleProtobufValueToProto3JSON","googleProtobufStructToProto3JSON","googleProtobufListValueToProto3JSON","googleProtobufDurationToProto3JSON","googleProtobufTimestampToProto3JSON","googleProtobufFieldMaskToProto3JSON","wrapperTypes","has","wrapperToProto3JSON","result","key","entries","field","fields","fieldResolvedType","resolvedType","fieldFullyQualifiedTypeName","Array","isArray","length","map","element","mapKey","mapValue","numericEnums","resolveEnumValueToNumber","resolveEnumValueToString","Number","isFinite","toString","Buffer","isBuffer","Uint8Array","bytesToProto3JSON","assert","constructor","name"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/proto3-json-serializer/build/src/toproto3json.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toProto3JSON = void 0;\nconst any_1 = require(\"./any\");\nconst bytes_1 = require(\"./bytes\");\nconst util_1 = require(\"./util\");\nconst enum_1 = require(\"./enum\");\nconst value_1 = require(\"./value\");\nconst duration_1 = require(\"./duration\");\nconst timestamp_1 = require(\"./timestamp\");\nconst wrappers_1 = require(\"./wrappers\");\nconst fieldmask_1 = require(\"./fieldmask\");\nconst id = (x) => {\n    return x;\n};\nfunction toProto3JSON(obj, options) {\n    const objType = obj.$type;\n    if (!objType) {\n        throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n    }\n    objType.resolveAll();\n    const typeName = (0, util_1.getFullyQualifiedTypeName)(objType);\n    // Types that require special handling according to\n    // https://developers.google.com/protocol-buffers/docs/proto3#json\n    if (typeName === '.google.protobuf.Any') {\n        return (0, any_1.googleProtobufAnyToProto3JSON)(obj, options);\n    }\n    if (typeName === '.google.protobuf.Value') {\n        return (0, value_1.googleProtobufValueToProto3JSON)(obj);\n    }\n    if (typeName === '.google.protobuf.Struct') {\n        return (0, value_1.googleProtobufStructToProto3JSON)(obj);\n    }\n    if (typeName === '.google.protobuf.ListValue') {\n        return (0, value_1.googleProtobufListValueToProto3JSON)(obj);\n    }\n    if (typeName === '.google.protobuf.Duration') {\n        return (0, duration_1.googleProtobufDurationToProto3JSON)(obj);\n    }\n    if (typeName === '.google.protobuf.Timestamp') {\n        return (0, timestamp_1.googleProtobufTimestampToProto3JSON)(obj);\n    }\n    if (typeName === '.google.protobuf.FieldMask') {\n        return (0, fieldmask_1.googleProtobufFieldMaskToProto3JSON)(obj);\n    }\n    if (util_1.wrapperTypes.has(typeName)) {\n        return (0, wrappers_1.wrapperToProto3JSON)(obj);\n    }\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        const field = objType.fields[key];\n        const fieldResolvedType = field.resolvedType;\n        const fieldFullyQualifiedTypeName = fieldResolvedType\n            ? (0, util_1.getFullyQualifiedTypeName)(fieldResolvedType)\n            : null;\n        if (value === null) {\n            result[key] = null;\n            continue;\n        }\n        if (Array.isArray(value)) {\n            if (value.length === 0) {\n                // ignore repeated fields with no values\n                continue;\n            }\n            // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n            result[key] = value.map(fieldResolvedType\n                ? element => {\n                    return toProto3JSON(element, options);\n                }\n                : id);\n            continue;\n        }\n        if (field.map) {\n            const map = {};\n            for (const [mapKey, mapValue] of Object.entries(value)) {\n                // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n                map[mapKey] = fieldResolvedType\n                    ? toProto3JSON(mapValue, options)\n                    : mapValue;\n            }\n            result[key] = map;\n            continue;\n        }\n        if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n            result[key] = null;\n            continue;\n        }\n        if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n            if (options === null || options === void 0 ? void 0 : options.numericEnums) {\n                result[key] = (0, enum_1.resolveEnumValueToNumber)(fieldResolvedType, value);\n            }\n            else {\n                result[key] = (0, enum_1.resolveEnumValueToString)(fieldResolvedType, value);\n            }\n            continue;\n        }\n        if (fieldResolvedType) {\n            result[key] = toProto3JSON(value, options);\n            continue;\n        }\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            typeof value === 'boolean' ||\n            value === null) {\n            if (typeof value === 'number' && !Number.isFinite(value)) {\n                result[key] = value.toString();\n                continue;\n            }\n            result[key] = value;\n            continue;\n        }\n        if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n            result[key] = (0, bytes_1.bytesToProto3JSON)(value);\n            continue;\n        }\n        // The remaining case is Long, everything else is an internal error\n        (0, util_1.assert)(value.constructor.name === 'Long', `toProto3JSON: don't know how to convert field ${key} with value ${value}`);\n        result[key] = value.toString();\n        continue;\n    }\n    return result;\n}\nexports.toProto3JSON = toProto3JSON;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}