{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n\nconst util_1 = require(\"../util\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\n\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\n\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\n\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\n\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\n\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+'; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst pkg = require('../../../package.json');\n/**\n * For backwards compatibility.\n */\n\n\nvar authclient_2 = require(\"./authclient\");\n\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", {\n  enumerable: true,\n  get: function () {\n    return authclient_2.DEFAULT_UNIVERSE;\n  }\n});\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\n\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file. The camelCased options\n   *   are aliases for the snake_cased options.\n   * @param additionalOptions **DEPRECATED, all options are available in the\n   *   `options` parameter.** Optional additional behavior customization options.\n   *   These currently customize expiration threshold time and whether to retry\n   *   on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super({ ...options,\n      ...additionalOptions\n    });\n    const opts = (0, util_1.originalOrCamelOptions)(options);\n\n    if (opts.get('type') !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n    }\n\n    const clientId = opts.get('client_id');\n    const clientSecret = opts.get('client_secret');\n    const tokenUrl = opts.get('token_url');\n    const subjectTokenType = opts.get('subject_token_type');\n    const workforcePoolUserProject = opts.get('workforce_pool_user_project');\n    const serviceAccountImpersonationUrl = opts.get('service_account_impersonation_url');\n    const serviceAccountImpersonation = opts.get('service_account_impersonation');\n    const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get('token_lifetime_seconds');\n\n    if (clientId) {\n      this.clientAuth = {\n        confidentialClientType: 'basic',\n        clientId,\n        clientSecret\n      };\n    }\n\n    this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth); // Default OAuth scope. This could be overridden via public property.\n\n    this.scopes = [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = opts.get('audience');\n    this.subjectTokenType = subjectTokenType;\n    this.workforcePoolUserProject = workforcePoolUserProject;\n    const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n\n    if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n      throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' + 'credentials.');\n    }\n\n    this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n    this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;\n\n    if (this.serviceAccountImpersonationLifetime) {\n      this.configLifetimeRequested = true;\n    } else {\n      this.configLifetimeRequested = false;\n      this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n    }\n\n    this.projectNumber = this.getProjectNumber(this.audience);\n  }\n  /** The service account email to be impersonated, if available. */\n\n\n  getServiceAccountEmail() {\n    var _a;\n\n    if (this.serviceAccountImpersonationUrl) {\n      if (this.serviceAccountImpersonationUrl.length > 256) {\n        /**\n         * Prevents DOS attacks.\n         * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n         **/\n        throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n      } // Parse email from URL. The formal looks as follows:\n      // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n\n\n      const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n      const result = re.exec(this.serviceAccountImpersonationUrl);\n      return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n    }\n\n    return null;\n  }\n  /**\n   * Provides a mechanism to inject GCP access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options, is retrieved.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\n   * @return A promise that resolves with the current GCP access token\n   *   response. If the current credential is expired, a new one is retrieved.\n   */\n\n\n  getAccessToken() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // If cached access token is unavailable or expired, force refresh.\n      if (!_this.cachedAccessToken || _this.isExpired(_this.cachedAccessToken)) {\n        yield _this.refreshAccessTokenAsync();\n      } // Return GCP access token in GetAccessTokenResponse format.\n\n\n      return {\n        token: _this.cachedAccessToken.access_token,\n        res: _this.cachedAccessToken.res\n      };\n    })();\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n\n\n  getRequestHeaders() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const accessTokenResponse = yield _this2.getAccessToken();\n      const headers = {\n        Authorization: `Bearer ${accessTokenResponse.token}`\n      };\n      return _this2.addSharedMetadataHeaders(headers);\n    })();\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * @return A promise that resolves with the project ID corresponding to the\n   *   current workload identity pool or current workforce pool if\n   *   determinable. For workforce pool credential, it returns the project ID\n   *   corresponding to the workforcePoolUserProject.\n   *   This is introduced to match the current pattern of using the Auth\n   *   library:\n   *   const projectId = await auth.getProjectId();\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n   *   const res = await client.request({ url });\n   *   The resource may not have permission\n   *   (resourcemanager.projects.get) to call this API or the required\n   *   scopes may not be selected:\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n   */\n\n\n  getProjectId() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const projectNumber = _this3.projectNumber || _this3.workforcePoolUserProject;\n\n      if (_this3.projectId) {\n        // Return previously determined project ID.\n        return _this3.projectId;\n      } else if (projectNumber) {\n        // Preferable not to use request() to avoid retrial policies.\n        const headers = yield _this3.getRequestHeaders();\n        const response = yield _this3.transporter.request({\n          headers,\n          url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n          responseType: 'json'\n        });\n        _this3.projectId = response.data.projectId;\n        return _this3.projectId;\n      }\n\n      return null;\n    })();\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  requestAsync(opts, retry = false) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let response;\n\n      try {\n        const requestHeaders = yield _this4.getRequestHeaders();\n        opts.headers = opts.headers || {};\n\n        if (requestHeaders && requestHeaders['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n        }\n\n        if (requestHeaders && requestHeaders.Authorization) {\n          opts.headers.Authorization = requestHeaders.Authorization;\n        }\n\n        response = yield _this4.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - forceRefreshOnFailure is true\n\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && _this4.forceRefreshOnFailure) {\n            yield _this4.refreshAccessTokenAsync();\n            return yield _this4.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return response;\n    })();\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * External credentials are exchanged for GCP access tokens via the token\n   * exchange endpoint and other settings provided in the client options\n   * object.\n   * If the service_account_impersonation_url is provided, an additional\n   * step to exchange the external account GCP access token for a service\n   * account impersonated token is performed.\n   * @return A promise that resolves with the fresh GCP access tokens.\n   */\n\n\n  refreshAccessTokenAsync() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // Retrieve the external credential.\n      const subjectToken = yield _this5.retrieveSubjectToken(); // Construct the STS credentials options.\n\n      const stsCredentialsOptions = {\n        grantType: STS_GRANT_TYPE,\n        audience: _this5.audience,\n        requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n        subjectToken,\n        subjectTokenType: _this5.subjectTokenType,\n        // generateAccessToken requires the provided access token to have\n        // scopes:\n        // https://www.googleapis.com/auth/iam or\n        // https://www.googleapis.com/auth/cloud-platform\n        // The new service account access token scopes will match the user\n        // provided ones.\n        scope: _this5.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : _this5.getScopesArray()\n      }; // Exchange the external credentials for a GCP access token.\n      // Client auth is prioritized over passing the workforcePoolUserProject\n      // parameter for STS token exchange.\n\n      const additionalOptions = !_this5.clientAuth && _this5.workforcePoolUserProject ? {\n        userProject: _this5.workforcePoolUserProject\n      } : undefined;\n      const additionalHeaders = {\n        'x-goog-api-client': _this5.getMetricsHeaderValue()\n      };\n      const stsResponse = yield _this5.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n\n      if (_this5.serviceAccountImpersonationUrl) {\n        _this5.cachedAccessToken = yield _this5.getImpersonatedAccessToken(stsResponse.access_token);\n      } else if (stsResponse.expires_in) {\n        // Save response in cached access token.\n        _this5.cachedAccessToken = {\n          access_token: stsResponse.access_token,\n          expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n          res: stsResponse.res\n        };\n      } else {\n        // Save response in cached access token.\n        _this5.cachedAccessToken = {\n          access_token: stsResponse.access_token,\n          res: stsResponse.res\n        };\n      } // Save credentials.\n\n\n      _this5.credentials = {};\n      Object.assign(_this5.credentials, _this5.cachedAccessToken);\n      delete _this5.credentials.res; // Trigger tokens event to notify external listeners.\n\n      _this5.emit('tokens', {\n        refresh_token: null,\n        expiry_date: _this5.cachedAccessToken.expiry_date,\n        access_token: _this5.cachedAccessToken.access_token,\n        token_type: 'Bearer',\n        id_token: null\n      }); // Return the cached access token.\n\n\n      return _this5.cachedAccessToken;\n    })();\n  }\n  /**\n   * Returns the workload identity pool project number if it is determinable\n   * from the audience resource name.\n   * @param audience The STS audience used to determine the project number.\n   * @return The project number associated with the workload identity pool, if\n   *   this can be determined from the STS audience field. Otherwise, null is\n   *   returned.\n   */\n\n\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return match[1];\n  }\n  /**\n   * Exchanges an external account GCP access token for a service\n   * account impersonated access token using iamcredentials\n   * GenerateAccessToken API.\n   * @param token The access token to exchange for a service account access\n   *   token.\n   * @return A promise that resolves with the service account impersonated\n   *   credentials response.\n   */\n\n\n  getImpersonatedAccessToken(token) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const opts = {\n        url: _this6.serviceAccountImpersonationUrl,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        data: {\n          scope: _this6.getScopesArray(),\n          lifetime: _this6.serviceAccountImpersonationLifetime + 's'\n        },\n        responseType: 'json'\n      };\n      const response = yield _this6.transporter.request(opts);\n      const successResponse = response.data;\n      return {\n        access_token: successResponse.accessToken,\n        // Convert from ISO format to timestamp.\n        expiry_date: new Date(successResponse.expireTime).getTime(),\n        res: response\n      };\n    })();\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param accessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\n   * @return The list of scopes for the requested GCP access token.\n   */\n\n\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    } else if (typeof this.scopes === 'undefined') {\n      return [DEFAULT_OAUTH_SCOPE];\n    } else {\n      return this.scopes;\n    }\n  }\n\n  getMetricsHeaderValue() {\n    const nodeVersion = process.version.replace(/^v/, '');\n    const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n    const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : 'unknown';\n    return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n  }\n\n}\n\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","BaseExternalAccountClient","DEFAULT_UNIVERSE","CLOUD_RESOURCE_MANAGER","EXTERNAL_ACCOUNT_TYPE","EXPIRATION_TIME_OFFSET","stream","require","authclient_1","sts","util_1","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","DEFAULT_OAUTH_SCOPE","DEFAULT_TOKEN_LIFESPAN","WORKFORCE_AUDIENCE_PATTERN","pkg","authclient_2","enumerable","get","AuthClient","constructor","options","additionalOptions","opts","originalOrCamelOptions","Error","type","clientId","clientSecret","tokenUrl","subjectTokenType","workforcePoolUserProject","serviceAccountImpersonationUrl","serviceAccountImpersonation","serviceAccountImpersonationLifetime","clientAuth","confidentialClientType","stsCredential","StsCredentials","scopes","cachedAccessToken","audience","workforceAudiencePattern","RegExp","match","configLifetimeRequested","projectNumber","getProjectNumber","getServiceAccountEmail","_a","length","RangeError","re","result","exec","groups","email","setCredentials","credentials","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","res","getRequestHeaders","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","callback","requestAsync","then","r","e","response","getProjectId","projectId","transporter","url","responseType","data","retry","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","forceRefreshOnFailure","subjectToken","retrieveSubjectToken","stsCredentialsOptions","grantType","requestedTokenType","scope","getScopesArray","userProject","undefined","additionalHeaders","getMetricsHeaderValue","stsResponse","exchangeToken","getImpersonatedAccessToken","expires_in","expiry_date","Date","getTime","assign","emit","refresh_token","token_type","id_token","method","lifetime","successResponse","accessToken","expireTime","now","eagerRefreshThresholdMillis","nodeVersion","process","version","replace","saImpersonation","credentialSourceType"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\nconst util_1 = require(\"../util\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = require('../../../package.json');\n/**\n * For backwards compatibility.\n */\nvar authclient_2 = require(\"./authclient\");\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", { enumerable: true, get: function () { return authclient_2.DEFAULT_UNIVERSE; } });\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super({ ...options, ...additionalOptions });\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        if (opts.get('type') !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        const clientId = opts.get('client_id');\n        const clientSecret = opts.get('client_secret');\n        const tokenUrl = opts.get('token_url');\n        const subjectTokenType = opts.get('subject_token_type');\n        const workforcePoolUserProject = opts.get('workforce_pool_user_project');\n        const serviceAccountImpersonationUrl = opts.get('service_account_impersonation_url');\n        const serviceAccountImpersonation = opts.get('service_account_impersonation');\n        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get('token_lifetime_seconds');\n        if (clientId) {\n            this.clientAuth = {\n                confidentialClientType: 'basic',\n                clientId,\n                clientSecret,\n            };\n        }\n        this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = opts.get('audience');\n        this.subjectTokenType = subjectTokenType;\n        this.workforcePoolUserProject = workforcePoolUserProject;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject &&\n            !this.audience.match(workforceAudiencePattern)) {\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\n                'credentials.');\n        }\n        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n        this.serviceAccountImpersonationLifetime =\n            serviceAccountImpersonationLifetime;\n        if (this.serviceAccountImpersonationLifetime) {\n            this.configLifetimeRequested = true;\n        }\n        else {\n            this.configLifetimeRequested = false;\n            this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n        }\n        this.projectNumber = this.getProjectNumber(this.audience);\n    }\n    /** The service account email to be impersonated, if available. */\n    getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            if (this.serviceAccountImpersonationUrl.length > 256) {\n                /**\n                 * Prevents DOS attacks.\n                 * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n                 **/\n                throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n            }\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n                responseType: 'json',\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\n            ? { userProject: this.workforcePoolUserProject }\n            : undefined;\n        const additionalHeaders = {\n            'x-goog-api-client': this.getMetricsHeaderValue(),\n        };\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + 's',\n            },\n            responseType: 'json',\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        else if (typeof this.scopes === 'undefined') {\n            return [DEFAULT_OAUTH_SCOPE];\n        }\n        else {\n            return this.scopes;\n        }\n    }\n    getMetricsHeaderValue() {\n        const nodeVersion = process.version.replace(/^v/, '');\n        const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n        const credentialSourceType = this.credentialSourceType\n            ? this.credentialSourceType\n            : 'unknown';\n        return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}