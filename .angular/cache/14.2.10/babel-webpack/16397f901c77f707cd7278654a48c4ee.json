{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _a, _b, _c;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentityPoolClient = void 0;\n\nconst fs = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n\nconst util_2 = require(\"../util\"); // fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\n\n\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : () => {});\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : () => {});\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : () => {});\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\n\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\n   * Instantiate an IdentityPoolClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid file-sourced or\n   * url-sourced credential or a workforce pool user project is provided\n   * with a non workforce audience.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file. The camelCased options\n   *   are aliases for the snake_cased options.\n   * @param additionalOptions **DEPRECATED, all options are available in the\n   *   `options` parameter.** Optional additional behavior customization options.\n   *   These currently customize expiration threshold time and whether to retry\n   *   on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super(options, additionalOptions);\n    const opts = (0, util_2.originalOrCamelOptions)(options);\n    const credentialSource = opts.get('credential_source');\n    const credentialSourceOpts = (0, util_2.originalOrCamelOptions)(credentialSource);\n    this.file = credentialSourceOpts.get('file');\n    this.url = credentialSourceOpts.get('url');\n    this.headers = credentialSourceOpts.get('headers');\n\n    if (this.file && this.url) {\n      throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n    } else if (this.file && !this.url) {\n      this.credentialSourceType = 'file';\n    } else if (!this.file && this.url) {\n      this.credentialSourceType = 'url';\n    } else {\n      throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n    }\n\n    const formatOpts = (0, util_2.originalOrCamelOptions)(credentialSourceOpts.get('format')); // Text is the default format type.\n\n    this.formatType = formatOpts.get('type') || 'text';\n    this.formatSubjectTokenFieldName = formatOpts.get('subject_token_field_name');\n\n    if (this.formatType !== 'json' && this.formatType !== 'text') {\n      throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n    }\n\n    if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n      throw new Error('Missing subject_token_field_name for JSON credential_source format');\n    }\n  }\n  /**\n   * Triggered when a external subject token is needed to be exchanged for a GCP\n   * access token via GCP STS endpoint.\n   * This uses the `options.credential_source` object to figure out how\n   * to retrieve the token using the current environment. In this case,\n   * this either retrieves the local credential from a file location (k8s\n   * workload) or by sending a GET request to a local metadata server (Azure\n   * workloads).\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  retrieveSubjectToken() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.file) {\n        return yield _this.getTokenFromFile(_this.file, _this.formatType, _this.formatSubjectTokenFieldName);\n      }\n\n      return yield _this.getTokenFromUrl(_this.url, _this.formatType, _this.formatSubjectTokenFieldName, _this.headers);\n    })();\n  }\n  /**\n   * Looks up the external subject token in the file path provided and\n   * resolves with that token.\n   * @param file The file path where the external credential is located.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n    return _asyncToGenerator(function* () {\n      // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = yield realpath(filePath);\n\n        if (!(yield lstat(filePath)).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        if (err instanceof Error) {\n          err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n        }\n\n        throw err;\n      }\n\n      let subjectToken;\n      const rawText = yield readFile(filePath, {\n        encoding: 'utf8'\n      });\n\n      if (formatType === 'text') {\n        subjectToken = rawText;\n      } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n        const json = JSON.parse(rawText);\n        subjectToken = json[formatSubjectTokenFieldName];\n      }\n\n      if (!subjectToken) {\n        throw new Error('Unable to parse the subject_token from the credential_source file');\n      }\n\n      return subjectToken;\n    })();\n  }\n  /**\n   * Sends a GET request to the URL provided and resolves with the returned\n   * external subject token.\n   * @param url The URL to call to retrieve the subject token. This is typically\n   *   a local metadata server.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @param headers The optional additional headers to send with the request to\n   *   the metadata server url.\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const opts = {\n        url,\n        method: 'GET',\n        headers,\n        responseType: formatType\n      };\n      let subjectToken;\n\n      if (formatType === 'text') {\n        const response = yield _this2.transporter.request(opts);\n        subjectToken = response.data;\n      } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n        const response = yield _this2.transporter.request(opts);\n        subjectToken = response.data[formatSubjectTokenFieldName];\n      }\n\n      if (!subjectToken) {\n        throw new Error('Unable to parse the subject_token from the credential_source URL');\n      }\n\n      return subjectToken;\n    })();\n  }\n\n}\n\nexports.IdentityPoolClient = IdentityPoolClient;","map":{"version":3,"names":["_a","_b","_c","Object","defineProperty","exports","value","IdentityPoolClient","fs","require","util_1","baseexternalclient_1","util_2","readFile","promisify","realpath","lstat","BaseExternalAccountClient","constructor","options","additionalOptions","opts","originalOrCamelOptions","credentialSource","get","credentialSourceOpts","file","url","headers","Error","credentialSourceType","formatOpts","formatType","formatSubjectTokenFieldName","retrieveSubjectToken","getTokenFromFile","getTokenFromUrl","filePath","isFile","err","message","subjectToken","rawText","encoding","json","JSON","parse","method","responseType","response","transporter","request","data"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-auth-library/build/src/auth/identitypoolclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IdentityPoolClient = void 0;\nconst fs = require(\"fs\");\nconst util_1 = require(\"util\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\nconst util_2 = require(\"../util\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : (() => { }));\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : (() => { }));\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : (() => { }));\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        const opts = (0, util_2.originalOrCamelOptions)(options);\n        const credentialSource = opts.get('credential_source');\n        const credentialSourceOpts = (0, util_2.originalOrCamelOptions)(credentialSource);\n        this.file = credentialSourceOpts.get('file');\n        this.url = credentialSourceOpts.get('url');\n        this.headers = credentialSourceOpts.get('headers');\n        if (this.file && this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n        }\n        else if (this.file && !this.url) {\n            this.credentialSourceType = 'file';\n        }\n        else if (!this.file && this.url) {\n            this.credentialSourceType = 'url';\n        }\n        else {\n            throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n        }\n        const formatOpts = (0, util_2.originalOrCamelOptions)(credentialSourceOpts.get('format'));\n        // Text is the default format type.\n        this.formatType = formatOpts.get('type') || 'text';\n        this.formatSubjectTokenFieldName = formatOpts.get('subject_token_field_name');\n        if (this.formatType !== 'json' && this.formatType !== 'text') {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n            throw new Error('Missing subject_token_field_name for JSON credential_source format');\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, { encoding: 'utf8' });\n        if (formatType === 'text') {\n            subjectToken = rawText;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source file');\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: 'GET',\n            headers,\n            responseType: formatType,\n        };\n        let subjectToken;\n        if (formatType === 'text') {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source URL');\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}