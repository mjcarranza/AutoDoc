{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.operation = exports.Operation = void 0;\n\nconst events_1 = require(\"events\");\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst operationProtos = require(\"../../protos/operations\");\n\nclass Operation extends events_1.EventEmitter {\n  /**\n   * Wrapper for a google.longrunnung.Operation.\n   *\n   * @constructor\n   *\n   * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\n   * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n   * operations service client and unpacking mechanisms for the operation.\n   * @param {BackoffSettings} backoffSettings - The backoff settings used in\n   * in polling the operation.\n   * @param {CallOptions} callOptions - CallOptions used in making get operation\n   * requests.\n   */\n  constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n    super();\n    this.completeListeners = 0;\n    this.hasActiveListeners = false;\n    this.latestResponse = grpcOp;\n    this.name = this.latestResponse.name;\n    this.done = this.latestResponse.done;\n    this.error = this.latestResponse.error;\n    this.longrunningDescriptor = longrunningDescriptor;\n    this.result = null;\n    this.metadata = null;\n    this.backoffSettings = backoffSettings;\n\n    this._unpackResponse(grpcOp);\n\n    this._listenForEvents();\n\n    this._callOptions = callOptions;\n  }\n  /**\n   * Begin listening for events on the operation. This method keeps track of how\n   * many \"complete\" listeners are registered and removed, making sure polling\n   * is handled automatically.\n   *\n   * As long as there is one active \"complete\" listener, the connection is open.\n   * When there are no more listeners, the polling stops.\n   *\n   * @private\n   */\n\n\n  _listenForEvents() {\n    this.on('newListener', event => {\n      if (event === 'complete') {\n        this.completeListeners++;\n\n        if (!this.hasActiveListeners) {\n          this.hasActiveListeners = true;\n          this.startPolling_();\n        }\n      }\n    });\n    this.on('removeListener', event => {\n      if (event === 'complete' && --this.completeListeners === 0) {\n        this.hasActiveListeners = false;\n      }\n    });\n  }\n  /**\n   * Cancels current polling api call and cancels the operation.\n   *\n   * @return {Promise} the promise of the OperationsClient#cancelOperation api\n   * request.\n   */\n\n\n  cancel() {\n    if (this.currentCallPromise_) {\n      this.currentCallPromise_.cancel();\n    }\n\n    const operationsClient = this.longrunningDescriptor.operationsClient;\n    const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\n    cancelRequest.name = this.latestResponse.name;\n    return operationsClient.cancelOperation(cancelRequest);\n  }\n\n  getOperation(callback) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const operationsClient = this.longrunningDescriptor.operationsClient;\n\n    function promisifyResponse() {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          if (self.latestResponse.error) {\n            const error = new googleError_1.GoogleError(self.latestResponse.error.message);\n            error.code = self.latestResponse.error.code;\n            reject(error);\n          } else {\n            resolve([self.result, self.metadata, self.latestResponse]);\n          }\n        });\n      }\n\n      return;\n    }\n\n    if (this.latestResponse.done) {\n      this._unpackResponse(this.latestResponse, callback);\n\n      return promisifyResponse();\n    }\n\n    const request = new operationProtos.google.longrunning.GetOperationRequest();\n    request.name = this.latestResponse.name;\n    this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\n    const noCallbackPromise = this.currentCallPromise_.then(responses => {\n      self.latestResponse = responses[0];\n\n      self._unpackResponse(responses[0], callback);\n\n      return promisifyResponse();\n    }, err => {\n      if (callback) {\n        callback(err);\n        return;\n      }\n\n      return Promise.reject(err);\n    });\n\n    if (!callback) {\n      return noCallbackPromise;\n    }\n  }\n\n  _unpackResponse(op, callback) {\n    const responseDecoder = this.longrunningDescriptor.responseDecoder;\n    const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n    let response;\n    let metadata;\n\n    if (op.done) {\n      if (op.result === 'error') {\n        const error = new googleError_1.GoogleError(op.error.message);\n        error.code = op.error.code;\n        this.error = error;\n\n        if (callback) {\n          callback(error);\n        }\n\n        return;\n      }\n\n      if (responseDecoder && op.response) {\n        this.response = op.response;\n        response = responseDecoder(op.response.value);\n        this.result = response;\n        this.done = true;\n      }\n    }\n\n    if (metadataDecoder && op.metadata) {\n      metadata = metadataDecoder(op.metadata.value);\n      this.metadata = metadata;\n    }\n\n    if (callback) {\n      callback(null, response, metadata, op);\n    }\n  }\n  /**\n   * Poll `getOperation` to check the operation's status. This runs a loop to\n   * ping using the backoff strategy specified at initialization.\n   *\n   * Note: This method is automatically called once a \"complete\" event handler\n   * is registered on the operation.\n   *\n   * @private\n   */\n\n\n  startPolling_() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let now = new Date();\n    const delayMult = this.backoffSettings.retryDelayMultiplier;\n    const maxDelay = this.backoffSettings.maxRetryDelayMillis;\n    let delay = this.backoffSettings.initialRetryDelayMillis;\n    let deadline = Infinity;\n\n    if (this.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n    }\n\n    let previousMetadataBytes;\n\n    if (this.latestResponse.metadata) {\n      previousMetadataBytes = this.latestResponse.metadata.value;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    function emit(event, ...args) {\n      self.emit(event, ...args);\n    } // Helper function to replace nodejs buffer's equals()\n\n\n    function arrayEquals(a, b) {\n      if (a.byteLength !== b.byteLength) {\n        return false;\n      }\n\n      for (let i = 0; i < a.byteLength; ++i) {\n        if (a[i] !== b[i]) return false;\n      }\n\n      return true;\n    }\n\n    function retry() {\n      if (!self.hasActiveListeners) {\n        return;\n      }\n\n      if (now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        setImmediate(emit, 'error', error);\n        return;\n      }\n\n      self.getOperation((err, result, metadata, rawResponse) => {\n        if (err) {\n          setImmediate(emit, 'error', err);\n          return;\n        }\n\n        if (!result) {\n          if (rawResponse.metadata && (!previousMetadataBytes || rawResponse && !arrayEquals(rawResponse.metadata.value, previousMetadataBytes))) {\n            setImmediate(emit, 'progress', metadata, rawResponse);\n            previousMetadataBytes = rawResponse.metadata.value;\n          } // special case: some APIs fail to set either result or error\n          // but set done = true (e.g. speech with silent file).\n          // Some APIs just use this for the normal completion\n          // (e.g. nodejs-contact-center-insights), so let's just return\n          // an empty response in this case.\n\n\n          if (rawResponse.done) {\n            setImmediate(emit, 'complete', {}, metadata, rawResponse);\n            return;\n          }\n\n          setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            retry();\n          }, delay);\n          return;\n        }\n\n        setImmediate(emit, 'complete', result, metadata, rawResponse);\n      });\n    }\n\n    retry();\n  }\n  /**\n   * Wraps the `complete` and `error` events in a Promise.\n   *\n   * @return {promise} - Promise that resolves on operation completion and rejects\n   * on operation error.\n   */\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on('error', reject).on('complete', (result, metadata, rawResponse) => {\n        resolve([result, metadata, rawResponse]);\n      });\n    });\n  }\n\n}\n\nexports.Operation = Operation;\n/**\n * Method used to create Operation objects.\n *\n * @constructor\n *\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n * operations service client and unpacking mechanisms for the operation.\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\n * in polling the operation.\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\n * requests.\n */\n\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n  return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\n\nexports.operation = operation;","map":{"version":3,"names":["Object","defineProperty","exports","value","operation","Operation","events_1","require","status_1","googleError_1","operationProtos","EventEmitter","constructor","grpcOp","longrunningDescriptor","backoffSettings","callOptions","completeListeners","hasActiveListeners","latestResponse","name","done","error","result","metadata","_unpackResponse","_listenForEvents","_callOptions","on","event","startPolling_","cancel","currentCallPromise_","operationsClient","cancelRequest","google","longrunning","CancelOperationRequest","cancelOperation","getOperation","callback","self","promisifyResponse","Promise","resolve","reject","GoogleError","message","code","request","GetOperationRequest","getOperationInternal","noCallbackPromise","then","responses","err","op","responseDecoder","metadataDecoder","response","now","Date","delayMult","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","delay","initialRetryDelayMillis","deadline","Infinity","totalTimeoutMillis","getTime","previousMetadataBytes","emit","args","arrayEquals","a","b","byteLength","i","retry","Status","DEADLINE_EXCEEDED","setImmediate","rawResponse","setTimeout","Math","min","promise"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/longRunningCalls/longrunning.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.operation = exports.Operation = void 0;\nconst events_1 = require(\"events\");\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst operationProtos = require(\"../../protos/operations\");\nclass Operation extends events_1.EventEmitter {\n    /**\n     * Wrapper for a google.longrunnung.Operation.\n     *\n     * @constructor\n     *\n     * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\n     * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n     * operations service client and unpacking mechanisms for the operation.\n     * @param {BackoffSettings} backoffSettings - The backoff settings used in\n     * in polling the operation.\n     * @param {CallOptions} callOptions - CallOptions used in making get operation\n     * requests.\n     */\n    constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n        super();\n        this.completeListeners = 0;\n        this.hasActiveListeners = false;\n        this.latestResponse = grpcOp;\n        this.name = this.latestResponse.name;\n        this.done = this.latestResponse.done;\n        this.error = this.latestResponse.error;\n        this.longrunningDescriptor = longrunningDescriptor;\n        this.result = null;\n        this.metadata = null;\n        this.backoffSettings = backoffSettings;\n        this._unpackResponse(grpcOp);\n        this._listenForEvents();\n        this._callOptions = callOptions;\n    }\n    /**\n     * Begin listening for events on the operation. This method keeps track of how\n     * many \"complete\" listeners are registered and removed, making sure polling\n     * is handled automatically.\n     *\n     * As long as there is one active \"complete\" listener, the connection is open.\n     * When there are no more listeners, the polling stops.\n     *\n     * @private\n     */\n    _listenForEvents() {\n        this.on('newListener', event => {\n            if (event === 'complete') {\n                this.completeListeners++;\n                if (!this.hasActiveListeners) {\n                    this.hasActiveListeners = true;\n                    this.startPolling_();\n                }\n            }\n        });\n        this.on('removeListener', event => {\n            if (event === 'complete' && --this.completeListeners === 0) {\n                this.hasActiveListeners = false;\n            }\n        });\n    }\n    /**\n     * Cancels current polling api call and cancels the operation.\n     *\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\n     * request.\n     */\n    cancel() {\n        if (this.currentCallPromise_) {\n            this.currentCallPromise_.cancel();\n        }\n        const operationsClient = this.longrunningDescriptor.operationsClient;\n        const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\n        cancelRequest.name = this.latestResponse.name;\n        return operationsClient.cancelOperation(cancelRequest);\n    }\n    getOperation(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const operationsClient = this.longrunningDescriptor.operationsClient;\n        function promisifyResponse() {\n            if (!callback) {\n                return new Promise((resolve, reject) => {\n                    if (self.latestResponse.error) {\n                        const error = new googleError_1.GoogleError(self.latestResponse.error.message);\n                        error.code = self.latestResponse.error.code;\n                        reject(error);\n                    }\n                    else {\n                        resolve([self.result, self.metadata, self.latestResponse]);\n                    }\n                });\n            }\n            return;\n        }\n        if (this.latestResponse.done) {\n            this._unpackResponse(this.latestResponse, callback);\n            return promisifyResponse();\n        }\n        const request = new operationProtos.google.longrunning.GetOperationRequest();\n        request.name = this.latestResponse.name;\n        this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\n        const noCallbackPromise = this.currentCallPromise_.then(responses => {\n            self.latestResponse = responses[0];\n            self._unpackResponse(responses[0], callback);\n            return promisifyResponse();\n        }, (err) => {\n            if (callback) {\n                callback(err);\n                return;\n            }\n            return Promise.reject(err);\n        });\n        if (!callback) {\n            return noCallbackPromise;\n        }\n    }\n    _unpackResponse(op, callback) {\n        const responseDecoder = this.longrunningDescriptor.responseDecoder;\n        const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n        let response;\n        let metadata;\n        if (op.done) {\n            if (op.result === 'error') {\n                const error = new googleError_1.GoogleError(op.error.message);\n                error.code = op.error.code;\n                this.error = error;\n                if (callback) {\n                    callback(error);\n                }\n                return;\n            }\n            if (responseDecoder && op.response) {\n                this.response = op.response;\n                response = responseDecoder(op.response.value);\n                this.result = response;\n                this.done = true;\n            }\n        }\n        if (metadataDecoder && op.metadata) {\n            metadata = metadataDecoder(op.metadata.value);\n            this.metadata = metadata;\n        }\n        if (callback) {\n            callback(null, response, metadata, op);\n        }\n    }\n    /**\n     * Poll `getOperation` to check the operation's status. This runs a loop to\n     * ping using the backoff strategy specified at initialization.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n    startPolling_() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        let now = new Date();\n        const delayMult = this.backoffSettings.retryDelayMultiplier;\n        const maxDelay = this.backoffSettings.maxRetryDelayMillis;\n        let delay = this.backoffSettings.initialRetryDelayMillis;\n        let deadline = Infinity;\n        if (this.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n        }\n        let previousMetadataBytes;\n        if (this.latestResponse.metadata) {\n            previousMetadataBytes = this.latestResponse.metadata.value;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function emit(event, ...args) {\n            self.emit(event, ...args);\n        }\n        // Helper function to replace nodejs buffer's equals()\n        function arrayEquals(a, b) {\n            if (a.byteLength !== b.byteLength) {\n                return false;\n            }\n            for (let i = 0; i < a.byteLength; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        function retry() {\n            if (!self.hasActiveListeners) {\n                return;\n            }\n            if (now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                setImmediate(emit, 'error', error);\n                return;\n            }\n            self.getOperation((err, result, metadata, rawResponse) => {\n                if (err) {\n                    setImmediate(emit, 'error', err);\n                    return;\n                }\n                if (!result) {\n                    if (rawResponse.metadata &&\n                        (!previousMetadataBytes ||\n                            (rawResponse &&\n                                !arrayEquals(rawResponse.metadata.value, previousMetadataBytes)))) {\n                        setImmediate(emit, 'progress', metadata, rawResponse);\n                        previousMetadataBytes = rawResponse.metadata.value;\n                    }\n                    // special case: some APIs fail to set either result or error\n                    // but set done = true (e.g. speech with silent file).\n                    // Some APIs just use this for the normal completion\n                    // (e.g. nodejs-contact-center-insights), so let's just return\n                    // an empty response in this case.\n                    if (rawResponse.done) {\n                        setImmediate(emit, 'complete', {}, metadata, rawResponse);\n                        return;\n                    }\n                    setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        retry();\n                    }, delay);\n                    return;\n                }\n                setImmediate(emit, 'complete', result, metadata, rawResponse);\n            });\n        }\n        retry();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {promise} - Promise that resolves on operation completion and rejects\n     * on operation error.\n     */\n    promise() {\n        return new Promise((resolve, reject) => {\n            this.on('error', reject).on('complete', (result, metadata, rawResponse) => {\n                resolve([result, metadata, rawResponse]);\n            });\n        });\n    }\n}\nexports.Operation = Operation;\n/**\n * Method used to create Operation objects.\n *\n * @constructor\n *\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n * operations service client and unpacking mechanisms for the operation.\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\n * in polling the operation.\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\n * requests.\n */\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n    return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\nexports.operation = operation;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACG,SAAR,GAAoB,KAAK,CAA7C;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,yBAAD,CAA/B;;AACA,MAAMF,SAAN,SAAwBC,QAAQ,CAACK,YAAjC,CAA8C;EAC1C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAW,CAACC,MAAD,EAASC,qBAAT,EAAgCC,eAAhC,EAAiDC,WAAjD,EAA8D;IACrE;IACA,KAAKC,iBAAL,GAAyB,CAAzB;IACA,KAAKC,kBAAL,GAA0B,KAA1B;IACA,KAAKC,cAAL,GAAsBN,MAAtB;IACA,KAAKO,IAAL,GAAY,KAAKD,cAAL,CAAoBC,IAAhC;IACA,KAAKC,IAAL,GAAY,KAAKF,cAAL,CAAoBE,IAAhC;IACA,KAAKC,KAAL,GAAa,KAAKH,cAAL,CAAoBG,KAAjC;IACA,KAAKR,qBAAL,GAA6BA,qBAA7B;IACA,KAAKS,MAAL,GAAc,IAAd;IACA,KAAKC,QAAL,GAAgB,IAAhB;IACA,KAAKT,eAAL,GAAuBA,eAAvB;;IACA,KAAKU,eAAL,CAAqBZ,MAArB;;IACA,KAAKa,gBAAL;;IACA,KAAKC,YAAL,GAAoBX,WAApB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIU,gBAAgB,GAAG;IACf,KAAKE,EAAL,CAAQ,aAAR,EAAuBC,KAAK,IAAI;MAC5B,IAAIA,KAAK,KAAK,UAAd,EAA0B;QACtB,KAAKZ,iBAAL;;QACA,IAAI,CAAC,KAAKC,kBAAV,EAA8B;UAC1B,KAAKA,kBAAL,GAA0B,IAA1B;UACA,KAAKY,aAAL;QACH;MACJ;IACJ,CARD;IASA,KAAKF,EAAL,CAAQ,gBAAR,EAA0BC,KAAK,IAAI;MAC/B,IAAIA,KAAK,KAAK,UAAV,IAAwB,EAAE,KAAKZ,iBAAP,KAA6B,CAAzD,EAA4D;QACxD,KAAKC,kBAAL,GAA0B,KAA1B;MACH;IACJ,CAJD;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIa,MAAM,GAAG;IACL,IAAI,KAAKC,mBAAT,EAA8B;MAC1B,KAAKA,mBAAL,CAAyBD,MAAzB;IACH;;IACD,MAAME,gBAAgB,GAAG,KAAKnB,qBAAL,CAA2BmB,gBAApD;IACA,MAAMC,aAAa,GAAG,IAAIxB,eAAe,CAACyB,MAAhB,CAAuBC,WAAvB,CAAmCC,sBAAvC,EAAtB;IACAH,aAAa,CAACd,IAAd,GAAqB,KAAKD,cAAL,CAAoBC,IAAzC;IACA,OAAOa,gBAAgB,CAACK,eAAjB,CAAiCJ,aAAjC,CAAP;EACH;;EACDK,YAAY,CAACC,QAAD,EAAW;IACnB;IACA,MAAMC,IAAI,GAAG,IAAb;IACA,MAAMR,gBAAgB,GAAG,KAAKnB,qBAAL,CAA2BmB,gBAApD;;IACA,SAASS,iBAAT,GAA6B;MACzB,IAAI,CAACF,QAAL,EAAe;QACX,OAAO,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;UACpC,IAAIJ,IAAI,CAACtB,cAAL,CAAoBG,KAAxB,EAA+B;YAC3B,MAAMA,KAAK,GAAG,IAAIb,aAAa,CAACqC,WAAlB,CAA8BL,IAAI,CAACtB,cAAL,CAAoBG,KAApB,CAA0ByB,OAAxD,CAAd;YACAzB,KAAK,CAAC0B,IAAN,GAAaP,IAAI,CAACtB,cAAL,CAAoBG,KAApB,CAA0B0B,IAAvC;YACAH,MAAM,CAACvB,KAAD,CAAN;UACH,CAJD,MAKK;YACDsB,OAAO,CAAC,CAACH,IAAI,CAAClB,MAAN,EAAckB,IAAI,CAACjB,QAAnB,EAA6BiB,IAAI,CAACtB,cAAlC,CAAD,CAAP;UACH;QACJ,CATM,CAAP;MAUH;;MACD;IACH;;IACD,IAAI,KAAKA,cAAL,CAAoBE,IAAxB,EAA8B;MAC1B,KAAKI,eAAL,CAAqB,KAAKN,cAA1B,EAA0CqB,QAA1C;;MACA,OAAOE,iBAAiB,EAAxB;IACH;;IACD,MAAMO,OAAO,GAAG,IAAIvC,eAAe,CAACyB,MAAhB,CAAuBC,WAAvB,CAAmCc,mBAAvC,EAAhB;IACAD,OAAO,CAAC7B,IAAR,GAAe,KAAKD,cAAL,CAAoBC,IAAnC;IACA,KAAKY,mBAAL,GAA2BC,gBAAgB,CAACkB,oBAAjB,CAAsCF,OAAtC,EAA+C,KAAKtB,YAApD,CAA3B;IACA,MAAMyB,iBAAiB,GAAG,KAAKpB,mBAAL,CAAyBqB,IAAzB,CAA8BC,SAAS,IAAI;MACjEb,IAAI,CAACtB,cAAL,GAAsBmC,SAAS,CAAC,CAAD,CAA/B;;MACAb,IAAI,CAAChB,eAAL,CAAqB6B,SAAS,CAAC,CAAD,CAA9B,EAAmCd,QAAnC;;MACA,OAAOE,iBAAiB,EAAxB;IACH,CAJyB,EAItBa,GAAD,IAAS;MACR,IAAIf,QAAJ,EAAc;QACVA,QAAQ,CAACe,GAAD,CAAR;QACA;MACH;;MACD,OAAOZ,OAAO,CAACE,MAAR,CAAeU,GAAf,CAAP;IACH,CAVyB,CAA1B;;IAWA,IAAI,CAACf,QAAL,EAAe;MACX,OAAOY,iBAAP;IACH;EACJ;;EACD3B,eAAe,CAAC+B,EAAD,EAAKhB,QAAL,EAAe;IAC1B,MAAMiB,eAAe,GAAG,KAAK3C,qBAAL,CAA2B2C,eAAnD;IACA,MAAMC,eAAe,GAAG,KAAK5C,qBAAL,CAA2B4C,eAAnD;IACA,IAAIC,QAAJ;IACA,IAAInC,QAAJ;;IACA,IAAIgC,EAAE,CAACnC,IAAP,EAAa;MACT,IAAImC,EAAE,CAACjC,MAAH,KAAc,OAAlB,EAA2B;QACvB,MAAMD,KAAK,GAAG,IAAIb,aAAa,CAACqC,WAAlB,CAA8BU,EAAE,CAAClC,KAAH,CAASyB,OAAvC,CAAd;QACAzB,KAAK,CAAC0B,IAAN,GAAaQ,EAAE,CAAClC,KAAH,CAAS0B,IAAtB;QACA,KAAK1B,KAAL,GAAaA,KAAb;;QACA,IAAIkB,QAAJ,EAAc;UACVA,QAAQ,CAAClB,KAAD,CAAR;QACH;;QACD;MACH;;MACD,IAAImC,eAAe,IAAID,EAAE,CAACG,QAA1B,EAAoC;QAChC,KAAKA,QAAL,GAAgBH,EAAE,CAACG,QAAnB;QACAA,QAAQ,GAAGF,eAAe,CAACD,EAAE,CAACG,QAAH,CAAYxD,KAAb,CAA1B;QACA,KAAKoB,MAAL,GAAcoC,QAAd;QACA,KAAKtC,IAAL,GAAY,IAAZ;MACH;IACJ;;IACD,IAAIqC,eAAe,IAAIF,EAAE,CAAChC,QAA1B,EAAoC;MAChCA,QAAQ,GAAGkC,eAAe,CAACF,EAAE,CAAChC,QAAH,CAAYrB,KAAb,CAA1B;MACA,KAAKqB,QAAL,GAAgBA,QAAhB;IACH;;IACD,IAAIgB,QAAJ,EAAc;MACVA,QAAQ,CAAC,IAAD,EAAOmB,QAAP,EAAiBnC,QAAjB,EAA2BgC,EAA3B,CAAR;IACH;EACJ;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI1B,aAAa,GAAG;IACZ;IACA,MAAMW,IAAI,GAAG,IAAb;IACA,IAAImB,GAAG,GAAG,IAAIC,IAAJ,EAAV;IACA,MAAMC,SAAS,GAAG,KAAK/C,eAAL,CAAqBgD,oBAAvC;IACA,MAAMC,QAAQ,GAAG,KAAKjD,eAAL,CAAqBkD,mBAAtC;IACA,IAAIC,KAAK,GAAG,KAAKnD,eAAL,CAAqBoD,uBAAjC;IACA,IAAIC,QAAQ,GAAGC,QAAf;;IACA,IAAI,KAAKtD,eAAL,CAAqBuD,kBAAzB,EAA6C;MACzCF,QAAQ,GAAGR,GAAG,CAACW,OAAJ,KAAgB,KAAKxD,eAAL,CAAqBuD,kBAAhD;IACH;;IACD,IAAIE,qBAAJ;;IACA,IAAI,KAAKrD,cAAL,CAAoBK,QAAxB,EAAkC;MAC9BgD,qBAAqB,GAAG,KAAKrD,cAAL,CAAoBK,QAApB,CAA6BrB,KAArD;IACH,CAdW,CAeZ;;;IACA,SAASsE,IAAT,CAAc5C,KAAd,EAAqB,GAAG6C,IAAxB,EAA8B;MAC1BjC,IAAI,CAACgC,IAAL,CAAU5C,KAAV,EAAiB,GAAG6C,IAApB;IACH,CAlBW,CAmBZ;;;IACA,SAASC,WAAT,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;MACvB,IAAID,CAAC,CAACE,UAAF,KAAiBD,CAAC,CAACC,UAAvB,EAAmC;QAC/B,OAAO,KAAP;MACH;;MACD,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACE,UAAtB,EAAkC,EAAEC,CAApC,EAAuC;QACnC,IAAIH,CAAC,CAACG,CAAD,CAAD,KAASF,CAAC,CAACE,CAAD,CAAd,EACI,OAAO,KAAP;MACP;;MACD,OAAO,IAAP;IACH;;IACD,SAASC,KAAT,GAAiB;MACb,IAAI,CAACvC,IAAI,CAACvB,kBAAV,EAA8B;QAC1B;MACH;;MACD,IAAI0C,GAAG,CAACW,OAAJ,MAAiBH,QAArB,EAA+B;QAC3B,MAAM9C,KAAK,GAAG,IAAIb,aAAa,CAACqC,WAAlB,CAA8B,yDAA9B,CAAd;QACAxB,KAAK,CAAC0B,IAAN,GAAaxC,QAAQ,CAACyE,MAAT,CAAgBC,iBAA7B;QACAC,YAAY,CAACV,IAAD,EAAO,OAAP,EAAgBnD,KAAhB,CAAZ;QACA;MACH;;MACDmB,IAAI,CAACF,YAAL,CAAkB,CAACgB,GAAD,EAAMhC,MAAN,EAAcC,QAAd,EAAwB4D,WAAxB,KAAwC;QACtD,IAAI7B,GAAJ,EAAS;UACL4B,YAAY,CAACV,IAAD,EAAO,OAAP,EAAgBlB,GAAhB,CAAZ;UACA;QACH;;QACD,IAAI,CAAChC,MAAL,EAAa;UACT,IAAI6D,WAAW,CAAC5D,QAAZ,KACC,CAACgD,qBAAD,IACIY,WAAW,IACR,CAACT,WAAW,CAACS,WAAW,CAAC5D,QAAZ,CAAqBrB,KAAtB,EAA6BqE,qBAA7B,CAHpB,CAAJ,EAG+E;YAC3EW,YAAY,CAACV,IAAD,EAAO,UAAP,EAAmBjD,QAAnB,EAA6B4D,WAA7B,CAAZ;YACAZ,qBAAqB,GAAGY,WAAW,CAAC5D,QAAZ,CAAqBrB,KAA7C;UACH,CAPQ,CAQT;UACA;UACA;UACA;UACA;;;UACA,IAAIiF,WAAW,CAAC/D,IAAhB,EAAsB;YAClB8D,YAAY,CAACV,IAAD,EAAO,UAAP,EAAmB,EAAnB,EAAuBjD,QAAvB,EAAiC4D,WAAjC,CAAZ;YACA;UACH;;UACDC,UAAU,CAAC,MAAM;YACbzB,GAAG,GAAG,IAAIC,IAAJ,EAAN;YACAK,KAAK,GAAGoB,IAAI,CAACC,GAAL,CAASrB,KAAK,GAAGJ,SAAjB,EAA4BE,QAA5B,CAAR;YACAgB,KAAK;UACR,CAJS,EAIPd,KAJO,CAAV;UAKA;QACH;;QACDiB,YAAY,CAACV,IAAD,EAAO,UAAP,EAAmBlD,MAAnB,EAA2BC,QAA3B,EAAqC4D,WAArC,CAAZ;MACH,CA9BD;IA+BH;;IACDJ,KAAK;EACR;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIQ,OAAO,GAAG;IACN,OAAO,IAAI7C,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACpC,KAAKjB,EAAL,CAAQ,OAAR,EAAiBiB,MAAjB,EAAyBjB,EAAzB,CAA4B,UAA5B,EAAwC,CAACL,MAAD,EAASC,QAAT,EAAmB4D,WAAnB,KAAmC;QACvExC,OAAO,CAAC,CAACrB,MAAD,EAASC,QAAT,EAAmB4D,WAAnB,CAAD,CAAP;MACH,CAFD;IAGH,CAJM,CAAP;EAKH;;AA7OyC;;AA+O9ClF,OAAO,CAACG,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,SAAT,CAAmBoD,EAAnB,EAAuB1C,qBAAvB,EAA8CC,eAA9C,EAA+DC,WAA/D,EAA4E;EACxE,OAAO,IAAIX,SAAJ,CAAcmD,EAAd,EAAkB1C,qBAAlB,EAAyCC,eAAzC,EAA0DC,WAA1D,CAAP;AACH;;AACDd,OAAO,CAACE,SAAR,GAAoBA,SAApB"},"metadata":{},"sourceType":"script"}