{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\n\n\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries; // TODO: define A/B testing values for retry behaviors.\n\n    /** Repeat the API call as long as necessary. */\n\n    function repeat() {\n      timeoutId = null;\n\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      retries++;\n      const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n\n        canceller = null;\n\n        if (retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat();\n          }, toSleep);\n        }\n      });\n\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n\n    };\n  };\n}\n\nexports.retryable = retryable;","map":{"version":3,"names":["Object","defineProperty","exports","value","retryable","status_1","require","googleError_1","timeout_1","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","error","GoogleError","code","Status","DEADLINE_EXCEEDED","toCall","addTimeoutArg","err","response","next","rawResponse","retryCodes","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/normalCalls/retries.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retryable = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    /**\n     * Equivalent to ``func``, but retries upon transient failure.\n     *\n     * Retrying is done through an exponential backoff algorithm configured\n     * by the options in ``retry``.\n     * @param {RequestType} argument The request object.\n     * @param {APICallback} callback The callback.\n     * @return {GRPCCall}\n     */\n    return (argument, callback) => {\n        let canceller;\n        let timeoutId;\n        let now = new Date();\n        let deadline;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        let retries = 0;\n        const maxRetries = retry.backoffSettings.maxRetries;\n        // TODO: define A/B testing values for retry behaviors.\n        /** Repeat the API call as long as necessary. */\n        function repeat() {\n            timeoutId = null;\n            if (deadline && now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            if (retries && retries >= maxRetries) {\n                const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' +\n                    'response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            retries++;\n            const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n            canceller = toCall(argument, (err, response, next, rawResponse) => {\n                if (!err) {\n                    callback(null, response, next, rawResponse);\n                    return;\n                }\n                canceller = null;\n                if (retry.retryCodes.indexOf(err.code) < 0) {\n                    err.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    callback(err);\n                }\n                else {\n                    const toSleep = Math.random() * delay;\n                    timeoutId = setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                        const newDeadline = deadline ? deadline - now.getTime() : 0;\n                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                        repeat();\n                    }, toSleep);\n                }\n            });\n            if (canceller instanceof Promise) {\n                canceller.catch(err => {\n                    callback(new googleError_1.GoogleError(err));\n                });\n            }\n        }\n        if (maxRetries && deadline) {\n            const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                'in backoffSettings.');\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n        }\n        else {\n            repeat();\n        }\n        return {\n            cancel() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (canceller) {\n                    canceller.cancel();\n                }\n                else {\n                    const error = new googleError_1.GoogleError('cancelled');\n                    error.code = status_1.Status.CANCELLED;\n                    callback(error);\n                }\n            },\n        };\n    };\n}\nexports.retryable = retryable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}