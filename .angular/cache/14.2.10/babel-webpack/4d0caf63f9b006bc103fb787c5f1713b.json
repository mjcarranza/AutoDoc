{"ast":null,"code":"\"use strict\";\n\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n  keepCase: false\n};\n\nvar tokenize = require(\"./tokenize\"),\n    Root = require(\"./root\"),\n    Type = require(\"./type\"),\n    Field = require(\"./field\"),\n    MapField = require(\"./mapfield\"),\n    OneOf = require(\"./oneof\"),\n    Enum = require(\"./enum\"),\n    Service = require(\"./service\"),\n    Method = require(\"./method\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n\nvar base10Re = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re = /^0[0-7]+$/,\n    base8NegRe = /^-?0[0-7]+$/,\n    numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\n\nfunction parse(source, root, options) {\n  /* eslint-disable callback-return */\n  if (!(root instanceof Root)) {\n    options = root;\n    root = new Root();\n  }\n\n  if (!options) options = parse.defaults;\n  var preferTrailingComment = options.preferTrailingComment || false;\n  var tn = tokenize(source, options.alternateCommentMode || false),\n      next = tn.next,\n      push = tn.push,\n      peek = tn.peek,\n      skip = tn.skip,\n      cmnt = tn.cmnt;\n  var head = true,\n      pkg,\n      imports,\n      weakImports,\n      syntax,\n      isProto3 = false;\n  var ptr = root;\n  var applyCase = options.keepCase ? function (name) {\n    return name;\n  } : util.camelCase;\n  /* istanbul ignore next */\n\n  function illegal(token, name, insideTryCatch) {\n    var filename = parse.filename;\n    if (!insideTryCatch) parse.filename = null;\n    return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n  }\n\n  function readString() {\n    var values = [],\n        token;\n\n    do {\n      /* istanbul ignore if */\n      if ((token = next()) !== \"\\\"\" && token !== \"'\") throw illegal(token);\n      values.push(next());\n      skip(token);\n      token = peek();\n    } while (token === \"\\\"\" || token === \"'\");\n\n    return values.join(\"\");\n  }\n\n  function readValue(acceptTypeRef) {\n    var token = next();\n\n    switch (token) {\n      case \"'\":\n      case \"\\\"\":\n        push(token);\n        return readString();\n\n      case \"true\":\n      case \"TRUE\":\n        return true;\n\n      case \"false\":\n      case \"FALSE\":\n        return false;\n    }\n\n    try {\n      return parseNumber(token,\n      /* insideTryCatch */\n      true);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (acceptTypeRef && typeRefRe.test(token)) return token;\n      /* istanbul ignore next */\n\n      throw illegal(token, \"value\");\n    }\n  }\n\n  function readRanges(target, acceptStrings) {\n    var token, start;\n\n    do {\n      if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\")) target.push(readString());else target.push([start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start]);\n    } while (skip(\",\", true));\n\n    skip(\";\");\n  }\n\n  function parseNumber(token, insideTryCatch) {\n    var sign = 1;\n\n    if (token.charAt(0) === \"-\") {\n      sign = -1;\n      token = token.substring(1);\n    }\n\n    switch (token) {\n      case \"inf\":\n      case \"INF\":\n      case \"Inf\":\n        return sign * Infinity;\n\n      case \"nan\":\n      case \"NAN\":\n      case \"Nan\":\n      case \"NaN\":\n        return NaN;\n\n      case \"0\":\n        return 0;\n    }\n\n    if (base10Re.test(token)) return sign * parseInt(token, 10);\n    if (base16Re.test(token)) return sign * parseInt(token, 16);\n    if (base8Re.test(token)) return sign * parseInt(token, 8);\n    /* istanbul ignore else */\n\n    if (numberRe.test(token)) return sign * parseFloat(token);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"number\", insideTryCatch);\n  }\n\n  function parseId(token, acceptNegative) {\n    switch (token) {\n      case \"max\":\n      case \"MAX\":\n      case \"Max\":\n        return 536870911;\n\n      case \"0\":\n        return 0;\n    }\n    /* istanbul ignore if */\n\n\n    if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n    if (base10NegRe.test(token)) return parseInt(token, 10);\n    if (base16NegRe.test(token)) return parseInt(token, 16);\n    /* istanbul ignore else */\n\n    if (base8NegRe.test(token)) return parseInt(token, 8);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"id\");\n  }\n\n  function parsePackage() {\n    /* istanbul ignore if */\n    if (pkg !== undefined) throw illegal(\"package\");\n    pkg = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n    ptr = ptr.define(pkg);\n    skip(\";\");\n  }\n\n  function parseImport() {\n    var token = peek();\n    var whichImports;\n\n    switch (token) {\n      case \"weak\":\n        whichImports = weakImports || (weakImports = []);\n        next();\n        break;\n\n      case \"public\":\n        next();\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        whichImports = imports || (imports = []);\n        break;\n    }\n\n    token = readString();\n    skip(\";\");\n    whichImports.push(token);\n  }\n\n  function parseSyntax() {\n    skip(\"=\");\n    syntax = readString();\n    isProto3 = syntax === \"proto3\";\n    /* istanbul ignore if */\n\n    if (!isProto3 && syntax !== \"proto2\") throw illegal(syntax, \"syntax\");\n    skip(\";\");\n  }\n\n  function parseCommon(parent, token) {\n    switch (token) {\n      case \"option\":\n        parseOption(parent, token);\n        skip(\";\");\n        return true;\n\n      case \"message\":\n        parseType(parent, token);\n        return true;\n\n      case \"enum\":\n        parseEnum(parent, token);\n        return true;\n\n      case \"service\":\n        parseService(parent, token);\n        return true;\n\n      case \"extend\":\n        parseExtension(parent, token);\n        return true;\n    }\n\n    return false;\n  }\n\n  function ifBlock(obj, fnIf, fnElse) {\n    var trailingLine = tn.line;\n\n    if (obj) {\n      if (typeof obj.comment !== \"string\") {\n        obj.comment = cmnt(); // try block-type comment\n      }\n\n      obj.filename = parse.filename;\n    }\n\n    if (skip(\"{\", true)) {\n      var token;\n\n      while ((token = next()) !== \"}\") fnIf(token);\n\n      skip(\";\", true);\n    } else {\n      if (fnElse) fnElse();\n      skip(\";\");\n      if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n    }\n  }\n\n  function parseType(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n    var type = new Type(token);\n    ifBlock(type, function parseType_block(token) {\n      if (parseCommon(type, token)) return;\n\n      switch (token) {\n        case \"map\":\n          parseMapField(type, token);\n          break;\n\n        case \"required\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        case \"optional\":\n          /* istanbul ignore if */\n          if (isProto3) {\n            parseField(type, \"proto3_optional\");\n          } else {\n            parseField(type, \"optional\");\n          }\n\n          break;\n\n        case \"oneof\":\n          parseOneOf(type, token);\n          break;\n\n        case \"extensions\":\n          readRanges(type.extensions || (type.extensions = []));\n          break;\n\n        case \"reserved\":\n          readRanges(type.reserved || (type.reserved = []), true);\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(type, \"optional\");\n          break;\n      }\n    });\n    parent.add(type);\n  }\n\n  function parseField(parent, rule, extend) {\n    var type = next();\n\n    if (type === \"group\") {\n      parseGroup(parent, rule);\n      return;\n    } // Type names can consume multiple tokens, in multiple variants:\n    //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n    // Keep reading tokens until we get a type name with no period at the end,\n    // and the next token does not start with a period.\n\n\n    while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n      type += next();\n    }\n    /* istanbul ignore if */\n\n\n    if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    name = applyCase(name);\n    skip(\"=\");\n    var field = new Field(name, parseId(next()), type, rule, extend);\n    ifBlock(field, function parseField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseField_line() {\n      parseInlineOptions(field);\n    });\n\n    if (rule === \"proto3_optional\") {\n      // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n      var oneof = new OneOf(\"_\" + name);\n      field.setOption(\"proto3_optional\", true);\n      oneof.add(field);\n      parent.add(oneof);\n    } else {\n      parent.add(field);\n    } // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n    // parsing proto2 descriptors without the option, where applicable. This must be done for\n    // all known packable types and anything that could be an enum (= is not a basic type).\n\n\n    if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption(\"packed\", false,\n    /* ifNotSet */\n    true);\n  }\n\n  function parseGroup(parent, rule) {\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    var fieldName = util.lcFirst(name);\n    if (name === fieldName) name = util.ucFirst(name);\n    skip(\"=\");\n    var id = parseId(next());\n    var type = new Type(name);\n    type.group = true;\n    var field = new Field(fieldName, id, name, rule);\n    field.filename = parse.filename;\n    ifBlock(type, function parseGroup_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(type, token);\n          skip(\";\");\n          break;\n\n        case \"required\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        case \"optional\":\n          /* istanbul ignore if */\n          if (isProto3) {\n            parseField(type, \"proto3_optional\");\n          } else {\n            parseField(type, \"optional\");\n          }\n\n          break;\n\n        case \"message\":\n          parseType(type, token);\n          break;\n\n        case \"enum\":\n          parseEnum(type, token);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw illegal(token);\n        // there are no groups with proto3 semantics\n      }\n    });\n    parent.add(type).add(field);\n  }\n\n  function parseMapField(parent) {\n    skip(\"<\");\n    var keyType = next();\n    /* istanbul ignore if */\n\n    if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n    skip(\",\");\n    var valueType = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n    skip(\">\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    skip(\"=\");\n    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n    ifBlock(field, function parseMapField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseMapField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field);\n  }\n\n  function parseOneOf(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var oneof = new OneOf(applyCase(token));\n    ifBlock(oneof, function parseOneOf_block(token) {\n      if (token === \"option\") {\n        parseOption(oneof, token);\n        skip(\";\");\n      } else {\n        push(token);\n        parseField(oneof, \"optional\");\n      }\n    });\n    parent.add(oneof);\n  }\n\n  function parseEnum(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var enm = new Enum(token);\n    ifBlock(enm, function parseEnum_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(enm, token);\n          skip(\";\");\n          break;\n\n        case \"reserved\":\n          readRanges(enm.reserved || (enm.reserved = []), true);\n          break;\n\n        default:\n          parseEnumValue(enm, token);\n      }\n    });\n    parent.add(enm);\n  }\n\n  function parseEnumValue(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token)) throw illegal(token, \"name\");\n    skip(\"=\");\n    var value = parseId(next(), true),\n        dummy = {\n      options: undefined\n    };\n\n    dummy.setOption = function (name, value) {\n      if (this.options === undefined) this.options = {};\n      this.options[name] = value;\n    };\n\n    ifBlock(dummy, function parseEnumValue_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(dummy, token); // skip\n\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseEnumValue_line() {\n      parseInlineOptions(dummy); // skip\n    });\n    parent.add(token, value, dummy.comment, dummy.options);\n  }\n\n  function parseOption(parent, token) {\n    var isCustom = skip(\"(\", true);\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token;\n    var option = name;\n    var propName;\n\n    if (isCustom) {\n      skip(\")\");\n      name = \"(\" + name + \")\";\n      option = name;\n      token = peek();\n\n      if (fqTypeRefRe.test(token)) {\n        propName = token.slice(1); //remove '.' before property name\n\n        name += token;\n        next();\n      }\n    }\n\n    skip(\"=\");\n    var optionValue = parseOptionValue(parent, name);\n    setParsedOption(parent, option, optionValue, propName);\n  }\n\n  function parseOptionValue(parent, name) {\n    // { a: \"foo\" b { c: \"bar\" } }\n    if (skip(\"{\", true)) {\n      var objectResult = {};\n\n      while (!skip(\"}\", true)) {\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next())) {\n          throw illegal(token, \"name\");\n        }\n\n        if (token === null) {\n          throw illegal(token, \"end of input\");\n        }\n\n        var value;\n        var propName = token;\n        skip(\":\", true);\n        if (peek() === \"{\") value = parseOptionValue(parent, name + \".\" + token);else if (peek() === \"[\") {\n          // option (my_option) = {\n          //     repeated_value: [ \"foo\", \"bar\" ]\n          // };\n          value = [];\n          var lastValue;\n\n          if (skip(\"[\", true)) {\n            do {\n              lastValue = readValue(true);\n              value.push(lastValue);\n            } while (skip(\",\", true));\n\n            skip(\"]\");\n\n            if (typeof lastValue !== \"undefined\") {\n              setOption(parent, name + \".\" + token, lastValue);\n            }\n          }\n        } else {\n          value = readValue(true);\n          setOption(parent, name + \".\" + token, value);\n        }\n        var prevValue = objectResult[propName];\n        if (prevValue) value = [].concat(prevValue).concat(value);\n        objectResult[propName] = value; // Semicolons and commas can be optional\n\n        skip(\",\", true);\n        skip(\";\", true);\n      }\n\n      return objectResult;\n    }\n\n    var simpleValue = readValue(true);\n    setOption(parent, name, simpleValue);\n    return simpleValue; // Does not enforce a delimiter to be universal\n  }\n\n  function setOption(parent, name, value) {\n    if (parent.setOption) parent.setOption(name, value);\n  }\n\n  function setParsedOption(parent, name, value, propName) {\n    if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n  }\n\n  function parseInlineOptions(parent) {\n    if (skip(\"[\", true)) {\n      do {\n        parseOption(parent, \"option\");\n      } while (skip(\",\", true));\n\n      skip(\"]\");\n    }\n\n    return parent;\n  }\n\n  function parseService(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n    var service = new Service(token);\n    ifBlock(service, function parseService_block(token) {\n      if (parseCommon(service, token)) return;\n      /* istanbul ignore else */\n\n      if (token === \"rpc\") parseMethod(service, token);else throw illegal(token);\n    });\n    parent.add(service);\n  }\n\n  function parseMethod(parent, token) {\n    // Get the comment of the preceding line now (if one exists) in case the\n    // method is defined across multiple lines.\n    var commentText = cmnt();\n    var type = token;\n    /* istanbul ignore if */\n\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token,\n        requestType,\n        requestStream,\n        responseType,\n        responseStream;\n    skip(\"(\");\n    if (skip(\"stream\", true)) requestStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    requestType = token;\n    skip(\")\");\n    skip(\"returns\");\n    skip(\"(\");\n    if (skip(\"stream\", true)) responseStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    responseType = token;\n    skip(\")\");\n    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n    method.comment = commentText;\n    ifBlock(method, function parseMethod_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(method, token);\n        skip(\";\");\n      } else throw illegal(token);\n    });\n    parent.add(method);\n  }\n\n  function parseExtension(parent, token) {\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n    var reference = token;\n    ifBlock(null, function parseExtension_block(token) {\n      switch (token) {\n        case \"required\":\n        case \"repeated\":\n          parseField(parent, token, reference);\n          break;\n\n        case \"optional\":\n          /* istanbul ignore if */\n          if (isProto3) {\n            parseField(parent, \"proto3_optional\", reference);\n          } else {\n            parseField(parent, \"optional\", reference);\n          }\n\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(parent, \"optional\", reference);\n          break;\n      }\n    });\n  }\n\n  var token;\n\n  while ((token = next()) !== null) {\n    switch (token) {\n      case \"package\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parsePackage();\n        break;\n\n      case \"import\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseImport();\n        break;\n\n      case \"syntax\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseSyntax();\n        break;\n\n      case \"option\":\n        parseOption(ptr, token);\n        skip(\";\");\n        break;\n\n      default:\n        /* istanbul ignore else */\n        if (parseCommon(ptr, token)) {\n          head = false;\n          continue;\n        }\n        /* istanbul ignore next */\n\n\n        throw illegal(token);\n    }\n  }\n\n  parse.filename = null;\n  return {\n    \"package\": pkg,\n    \"imports\": imports,\n    weakImports: weakImports,\n    syntax: syntax,\n    root: root\n  };\n}\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */","map":{"version":3,"names":["module","exports","parse","filename","defaults","keepCase","tokenize","require","Root","Type","Field","MapField","OneOf","Enum","Service","Method","types","util","base10Re","base10NegRe","base16Re","base16NegRe","base8Re","base8NegRe","numberRe","nameRe","typeRefRe","fqTypeRefRe","source","root","options","preferTrailingComment","tn","alternateCommentMode","next","push","peek","skip","cmnt","head","pkg","imports","weakImports","syntax","isProto3","ptr","applyCase","name","camelCase","illegal","token","insideTryCatch","Error","line","readString","values","join","readValue","acceptTypeRef","parseNumber","e","test","readRanges","target","acceptStrings","start","parseId","sign","charAt","substring","Infinity","NaN","parseInt","parseFloat","acceptNegative","parsePackage","undefined","define","parseImport","whichImports","parseSyntax","parseCommon","parent","parseOption","parseType","parseEnum","parseService","parseExtension","ifBlock","obj","fnIf","fnElse","trailingLine","comment","type","parseType_block","parseMapField","parseField","parseOneOf","extensions","reserved","add","rule","extend","parseGroup","endsWith","startsWith","field","parseField_block","parseField_line","parseInlineOptions","oneof","setOption","repeated","packed","basic","fieldName","lcFirst","ucFirst","id","group","parseGroup_block","keyType","mapKey","valueType","parseMapField_block","parseMapField_line","parseOneOf_block","enm","parseEnum_block","parseEnumValue","value","dummy","parseEnumValue_block","parseEnumValue_line","isCustom","option","propName","slice","optionValue","parseOptionValue","setParsedOption","objectResult","lastValue","prevValue","concat","simpleValue","service","parseService_block","parseMethod","commentText","requestType","requestStream","responseType","responseStream","method","parseMethod_block","reference","parseExtension_block"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/protobufjs/src/parse.js"],"sourcesContent":["\"use strict\";\nmodule.exports = parse;\n\nparse.filename = null;\nparse.defaults = { keepCase: false };\n\nvar tokenize  = require(\"./tokenize\"),\n    Root      = require(\"./root\"),\n    Type      = require(\"./type\"),\n    Field     = require(\"./field\"),\n    MapField  = require(\"./mapfield\"),\n    OneOf     = require(\"./oneof\"),\n    Enum      = require(\"./enum\"),\n    Service   = require(\"./service\"),\n    Method    = require(\"./method\"),\n    types     = require(\"./types\"),\n    util      = require(\"./util\");\n\nvar base10Re    = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re     = /^0[0-7]+$/,\n    base8NegRe  = /^-?0[0-7]+$/,\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n    /* eslint-disable callback-return */\n    if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options)\n        options = parse.defaults;\n\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false),\n        next = tn.next,\n        push = tn.push,\n        peek = tn.peek,\n        skip = tn.skip,\n        cmnt = tn.cmnt;\n\n    var head = true,\n        pkg,\n        imports,\n        weakImports,\n        syntax,\n        isProto3 = false;\n\n    var ptr = root;\n\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\n\n    /* istanbul ignore next */\n    function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch)\n            parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n\n    function readString() {\n        var values = [],\n            token;\n        do {\n            /* istanbul ignore if */\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\n                throw illegal(token);\n\n            values.push(next());\n            skip(token);\n            token = peek();\n        } while (token === \"\\\"\" || token === \"'\");\n        return values.join(\"\");\n    }\n\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch (token) {\n            case \"'\":\n            case \"\\\"\":\n                push(token);\n                return readString();\n            case \"true\": case \"TRUE\":\n                return true;\n            case \"false\": case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n\n            /* istanbul ignore else */\n            if (acceptTypeRef && typeRefRe.test(token))\n                return token;\n\n            /* istanbul ignore next */\n            throw illegal(token, \"value\");\n        }\n    }\n\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\n                target.push(readString());\n            else\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\n        } while (skip(\",\", true));\n        skip(\";\");\n    }\n\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch (token) {\n            case \"inf\": case \"INF\": case \"Inf\":\n                return sign * Infinity;\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token))\n            return sign * parseInt(token, 10);\n        if (base16Re.test(token))\n            return sign * parseInt(token, 16);\n        if (base8Re.test(token))\n            return sign * parseInt(token, 8);\n\n        /* istanbul ignore else */\n        if (numberRe.test(token))\n            return sign * parseFloat(token);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"number\", insideTryCatch);\n    }\n\n    function parseId(token, acceptNegative) {\n        switch (token) {\n            case \"max\": case \"MAX\": case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n\n        /* istanbul ignore if */\n        if (!acceptNegative && token.charAt(0) === \"-\")\n            throw illegal(token, \"id\");\n\n        if (base10NegRe.test(token))\n            return parseInt(token, 10);\n        if (base16NegRe.test(token))\n            return parseInt(token, 16);\n\n        /* istanbul ignore else */\n        if (base8NegRe.test(token))\n            return parseInt(token, 8);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"id\");\n    }\n\n    function parsePackage() {\n\n        /* istanbul ignore if */\n        if (pkg !== undefined)\n            throw illegal(\"package\");\n\n        pkg = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(pkg))\n            throw illegal(pkg, \"name\");\n\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch (token) {\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n                // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n\n        /* istanbul ignore if */\n        if (!isProto3 && syntax !== \"proto2\")\n            throw illegal(syntax, \"syntax\");\n\n        skip(\";\");\n    }\n\n    function parseCommon(parent, token) {\n        switch (token) {\n\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n\n            case \"message\":\n                parseType(parent, token);\n                return true;\n\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n\n            case \"service\":\n                parseService(parent, token);\n                return true;\n\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if(typeof obj.comment !== \"string\") {\n              obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while ((token = next()) !== \"}\")\n                fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse)\n                fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n\n    function parseType(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token))\n                return;\n\n            switch (token) {\n\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n            type += next();\n        }\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(type))\n            throw illegal(type, \"type\");\n\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        name = applyCase(name);\n        skip(\"=\");\n\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n\n    function parseGroup(parent, rule) {\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName)\n            name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch (token) {\n\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"message\":\n                    parseType(type, token);\n                    break;\n\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n\n                /* istanbul ignore next */\n                default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type)\n              .add(field);\n    }\n\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n\n        /* istanbul ignore if */\n        if (types.mapKey[keyType] === undefined)\n            throw illegal(keyType, \"type\");\n\n        skip(\",\");\n        var valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n\n    function parseOneOf(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n\n    function parseEnum(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n          switch(token) {\n            case \"option\":\n              parseOption(enm, token);\n              skip(\";\");\n              break;\n\n            case \"reserved\":\n              readRanges(enm.reserved || (enm.reserved = []), true);\n              break;\n\n            default:\n              parseEnumValue(enm, token);\n          }\n        });\n        parent.add(enm);\n    }\n\n    function parseEnumValue(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token))\n            throw illegal(token, \"name\");\n\n        skip(\"=\");\n        var value = parseId(next(), true),\n            dummy = {\n                options: undefined\n            };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined)\n                this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.options);\n    }\n\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token;\n        var option = name;\n        var propName;\n\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            option = name;\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                propName = token.slice(1); //remove '.' before property name\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        var optionValue = parseOptionValue(parent, name);\n        setParsedOption(parent, option, optionValue, propName);\n    }\n\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n\n            while (!skip(\"}\", true)) {\n                /* istanbul ignore if */\n                if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                  throw illegal(token, \"end of input\");\n                }\n\n                var value;\n                var propName = token;\n\n                skip(\":\", true);\n\n                if (peek() === \"{\")\n                    value = parseOptionValue(parent, name + \".\" + token);\n                else if (peek() === \"[\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        } while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n\n                var prevValue = objectResult[propName];\n\n                if (prevValue)\n                    value = [].concat(prevValue).concat(value);\n\n                objectResult[propName] = value;\n\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n\n            return objectResult;\n        }\n\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n        // Does not enforce a delimiter to be universal\n    }\n\n    function setOption(parent, name, value) {\n        if (parent.setOption)\n            parent.setOption(name, value);\n    }\n\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption)\n            parent.setParsedOption(name, value, propName);\n    }\n\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            } while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n\n    function parseService(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token))\n                return;\n\n            /* istanbul ignore else */\n            if (token === \"rpc\")\n                parseMethod(service, token);\n            else\n                throw illegal(token);\n        });\n        parent.add(service);\n    }\n\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n\n        var type = token;\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token,\n            requestType, requestStream,\n            responseType, responseStream;\n\n        skip(\"(\");\n        if (skip(\"stream\", true))\n            requestStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        requestType = token;\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\n        if (skip(\"stream\", true))\n            responseStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        responseType = token;\n        skip(\")\");\n\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        });\n        parent.add(method);\n    }\n\n    function parseExtension(parent, token) {\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"reference\");\n\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch (token) {\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n\n    var token;\n    while ((token = next()) !== null) {\n        switch (token) {\n\n            case \"package\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parsePackage();\n                break;\n\n            case \"import\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseImport();\n                break;\n\n            case \"syntax\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseSyntax();\n                break;\n\n            case \"option\":\n\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    parse.filename = null;\n    return {\n        \"package\"     : pkg,\n        \"imports\"     : imports,\n         weakImports  : weakImports,\n         syntax       : syntax,\n         root         : root\n    };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}