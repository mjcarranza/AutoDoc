{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.overrideHttpRules = exports.transcode = exports.isProto3OptionalField = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopyWithoutMatchedFields = exports.getField = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst httpOptionName = '(google.api.http)';\nconst proto3OptionalName = 'proto3_optional'; // List of methods as defined in google/api/http.proto (see HttpRule)\n\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\n\nfunction getField(request, field, allowObjects = false // in most cases, we need leaf fields\n) {\n  const parts = field.split('.');\n  let value = request;\n\n  for (const part of parts) {\n    if (typeof value !== 'object') {\n      return undefined;\n    }\n\n    value = value[part];\n  }\n\n  if (!allowObjects && typeof value === 'object' && !Array.isArray(value) && value !== null) {\n    return undefined;\n  }\n\n  return value;\n}\n\nexports.getField = getField;\n\nfunction deepCopyWithoutMatchedFields(request, fieldsToSkip, fullNamePrefix = '') {\n  if (typeof request !== 'object' || request === null) {\n    return request;\n  }\n\n  const copy = Object.assign({}, request);\n\n  for (const key in copy) {\n    if (fieldsToSkip.has(`${fullNamePrefix}${key}`)) {\n      delete copy[key];\n      continue;\n    }\n\n    const nextFullNamePrefix = `${fullNamePrefix}${key}.`;\n\n    if (Array.isArray(copy[key])) {\n      // a field of an array cannot be addressed as \"request.field\", so we omit the skipping logic for array descendants\n      copy[key] = copy[key].map(value => deepCopyWithoutMatchedFields(value, new Set()));\n    } else if (typeof copy[key] === 'object' && copy[key] !== null) {\n      copy[key] = deepCopyWithoutMatchedFields(copy[key], fieldsToSkip, nextFullNamePrefix);\n    }\n  }\n\n  return copy;\n}\n\nexports.deepCopyWithoutMatchedFields = deepCopyWithoutMatchedFields;\n\nfunction deleteField(request, field) {\n  const parts = field.split('.');\n\n  while (parts.length > 1) {\n    if (typeof request !== 'object') {\n      return;\n    }\n\n    const part = parts.shift();\n    request = request[part];\n  }\n\n  const part = parts.shift();\n\n  if (typeof request !== 'object') {\n    return;\n  }\n\n  delete request[part];\n}\n\nexports.deleteField = deleteField;\n\nfunction buildQueryStringComponents(request, prefix = '') {\n  const resultList = [];\n\n  for (const key in request) {\n    if (Array.isArray(request[key])) {\n      for (const value of request[key]) {\n        resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n      }\n    } else if (typeof request[key] === 'object' && request[key] !== null) {\n      resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n    } else {\n      resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n    }\n  }\n\n  return resultList;\n}\n\nexports.buildQueryStringComponents = buildQueryStringComponents;\n\nfunction encodeWithSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithSlashes = encodeWithSlashes;\n\nfunction encodeWithoutSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction applyPattern(pattern, fieldValue) {\n  if (!pattern || pattern === '*') {\n    return encodeWithSlashes(fieldValue);\n  }\n\n  if (!pattern.includes('*') && pattern !== fieldValue) {\n    return undefined;\n  } // since we're converting the pattern to a regex, make necessary precautions:\n\n\n  const regex = new RegExp('^' + escapeRegExp(pattern).replace(/\\\\\\*\\\\\\*/g, '(.+)').replace(/\\\\\\*/g, '([^/]+)') + '$');\n\n  if (!fieldValue.match(regex)) {\n    return undefined;\n  }\n\n  return encodeWithoutSlashes(fieldValue);\n}\n\nexports.applyPattern = applyPattern;\n\nfunction fieldToCamelCase(field) {\n  const parts = field.split('.');\n  return parts.map(part => (0, util_1.toCamelCase)(part)).join('.');\n}\n\nfunction match(request, pattern) {\n  let url = pattern;\n  const matchedFields = [];\n\n  for (;;) {\n    const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n\n    if (!match) {\n      break;\n    }\n\n    const [, before, field, pattern, after] = match;\n    const camelCasedField = fieldToCamelCase(field);\n    matchedFields.push(fieldToCamelCase(camelCasedField));\n    const fieldValue = getField(request, camelCasedField);\n\n    if (fieldValue === undefined) {\n      return undefined;\n    }\n\n    const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n\n    if (appliedPattern === undefined) {\n      return undefined;\n    }\n\n    url = before + appliedPattern + after;\n  }\n\n  return {\n    matchedFields,\n    url\n  };\n}\n\nexports.match = match;\n\nfunction flattenObject(request) {\n  const result = {};\n\n  for (const key in request) {\n    if (request[key] === undefined) {\n      continue;\n    }\n\n    if (Array.isArray(request[key])) {\n      // According to the http.proto comments, a repeated field may only\n      // contain primitive types, so no extra recursion here.\n      result[key] = request[key];\n      continue;\n    }\n\n    if (typeof request[key] === 'object' && request[key] !== null) {\n      const nested = flattenObject(request[key]);\n\n      for (const nestedKey in nested) {\n        result[`${key}.${nestedKey}`] = nested[nestedKey];\n      }\n\n      continue;\n    }\n\n    result[key] = request[key];\n  }\n\n  return result;\n}\n\nexports.flattenObject = flattenObject;\n\nfunction isProto3OptionalField(field) {\n  return field && field.options && field.options[proto3OptionalName];\n}\n\nexports.isProto3OptionalField = isProto3OptionalField;\n\nfunction transcode(request, parsedOptions) {\n  const httpRules = [];\n\n  for (const option of parsedOptions) {\n    if (!(httpOptionName in option)) {\n      continue;\n    }\n\n    const httpRule = option[httpOptionName];\n    httpRules.push(httpRule);\n\n    if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n      const additionalBindings = Array.isArray(httpRule.additional_bindings) ? httpRule.additional_bindings : [httpRule.additional_bindings];\n      httpRules.push(...additionalBindings);\n    }\n  }\n\n  for (const httpRule of httpRules) {\n    for (const httpMethod of supportedHttpMethods) {\n      if (!(httpMethod in httpRule)) {\n        continue;\n      }\n\n      const pathTemplate = httpRule[httpMethod];\n      const matchResult = match(request, pathTemplate);\n\n      if (matchResult === undefined) {\n        continue;\n      }\n\n      const {\n        url,\n        matchedFields\n      } = matchResult;\n      let data = deepCopyWithoutMatchedFields(request, new Set(matchedFields));\n\n      if (httpRule.body === '*') {\n        return {\n          httpMethod,\n          url,\n          queryString: '',\n          data\n        };\n      } // one field possibly goes to request data, others go to query string\n\n\n      const queryStringObject = data;\n\n      if (httpRule.body) {\n        data = getField(queryStringObject, fieldToCamelCase(httpRule.body),\n        /*allowObjects:*/\n        true);\n        deleteField(queryStringObject, fieldToCamelCase(httpRule.body));\n      } else {\n        data = '';\n      }\n\n      const queryStringComponents = buildQueryStringComponents(queryStringObject);\n      const queryString = queryStringComponents.join('&');\n\n      if (!data || typeof data === 'object' && Object.keys(data).length === 0) {\n        data = '';\n      }\n\n      return {\n        httpMethod,\n        url,\n        queryString,\n        data\n      };\n    }\n  }\n\n  return undefined;\n}\n\nexports.transcode = transcode; // Override the protobuf json's the http rules.\n\nfunction overrideHttpRules(httpRules, protoJson) {\n  for (const rule of httpRules) {\n    if (!rule.selector) {\n      continue;\n    }\n\n    const rpc = protoJson.lookup(rule.selector); // Not support override on non-exist RPC or a RPC without an annotation.\n    // We could reconsider if we have the use case later.\n\n    if (!rpc || !rpc.parsedOptions) {\n      continue;\n    }\n\n    for (const item of rpc.parsedOptions) {\n      if (!(httpOptionName in item)) {\n        continue;\n      }\n\n      const httpOptions = item[httpOptionName];\n\n      for (const httpMethod in httpOptions) {\n        if (httpMethod in rule) {\n          if (httpMethod === 'additional_bindings') {\n            continue;\n          }\n\n          httpOptions[httpMethod] = rule[httpMethod];\n        }\n\n        if (rule.additional_bindings) {\n          httpOptions['additional_bindings'] = !httpOptions['additional_bindings'] ? [] : Array.isArray(httpOptions['additional_bindings']) ? httpOptions['additional_bindings'] : [httpOptions['additional_bindings']]; // Make the additional_binding to be an array if it is not.\n\n          httpOptions['additional_bindings'].push(...rule.additional_bindings);\n        }\n      }\n    }\n  }\n}\n\nexports.overrideHttpRules = overrideHttpRules;","map":{"version":3,"names":["Object","defineProperty","exports","value","overrideHttpRules","transcode","isProto3OptionalField","flattenObject","match","applyPattern","encodeWithoutSlashes","encodeWithSlashes","buildQueryStringComponents","deleteField","deepCopyWithoutMatchedFields","getField","util_1","require","httpOptionName","proto3OptionalName","supportedHttpMethods","request","field","allowObjects","parts","split","part","undefined","Array","isArray","fieldsToSkip","fullNamePrefix","copy","assign","key","has","nextFullNamePrefix","map","Set","length","shift","prefix","resultList","push","toString","str","c","encodeURIComponent","join","escapeRegExp","replace","pattern","fieldValue","includes","regex","RegExp","fieldToCamelCase","toCamelCase","url","matchedFields","before","after","camelCasedField","appliedPattern","result","nested","nestedKey","options","parsedOptions","httpRules","option","httpRule","additional_bindings","additionalBindings","httpMethod","pathTemplate","matchResult","data","body","queryString","queryStringObject","queryStringComponents","keys","protoJson","rule","selector","rpc","lookup","item","httpOptions"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/transcoding.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.overrideHttpRules = exports.transcode = exports.isProto3OptionalField = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopyWithoutMatchedFields = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\nconst proto3OptionalName = 'proto3_optional';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field, allowObjects = false // in most cases, we need leaf fields\n) {\n    const parts = field.split('.');\n    let value = request;\n    for (const part of parts) {\n        if (typeof value !== 'object') {\n            return undefined;\n        }\n        value = value[part];\n    }\n    if (!allowObjects &&\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        value !== null) {\n        return undefined;\n    }\n    return value;\n}\nexports.getField = getField;\nfunction deepCopyWithoutMatchedFields(request, fieldsToSkip, fullNamePrefix = '') {\n    if (typeof request !== 'object' || request === null) {\n        return request;\n    }\n    const copy = Object.assign({}, request);\n    for (const key in copy) {\n        if (fieldsToSkip.has(`${fullNamePrefix}${key}`)) {\n            delete copy[key];\n            continue;\n        }\n        const nextFullNamePrefix = `${fullNamePrefix}${key}.`;\n        if (Array.isArray(copy[key])) {\n            // a field of an array cannot be addressed as \"request.field\", so we omit the skipping logic for array descendants\n            copy[key] = copy[key].map(value => deepCopyWithoutMatchedFields(value, new Set()));\n        }\n        else if (typeof copy[key] === 'object' && copy[key] !== null) {\n            copy[key] = deepCopyWithoutMatchedFields(copy[key], fieldsToSkip, nextFullNamePrefix);\n        }\n    }\n    return copy;\n}\nexports.deepCopyWithoutMatchedFields = deepCopyWithoutMatchedFields;\nfunction deleteField(request, field) {\n    const parts = field.split('.');\n    while (parts.length > 1) {\n        if (typeof request !== 'object') {\n            return;\n        }\n        const part = parts.shift();\n        request = request[part];\n    }\n    const part = parts.shift();\n    if (typeof request !== 'object') {\n        return;\n    }\n    delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request, prefix = '') {\n    const resultList = [];\n    for (const key in request) {\n        if (Array.isArray(request[key])) {\n            for (const value of request[key]) {\n                resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n            }\n        }\n        else if (typeof request[key] === 'object' && request[key] !== null) {\n            resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n        }\n        else {\n            resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n        }\n    }\n    return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n    if (!pattern || pattern === '*') {\n        return encodeWithSlashes(fieldValue);\n    }\n    if (!pattern.includes('*') && pattern !== fieldValue) {\n        return undefined;\n    }\n    // since we're converting the pattern to a regex, make necessary precautions:\n    const regex = new RegExp('^' +\n        escapeRegExp(pattern)\n            .replace(/\\\\\\*\\\\\\*/g, '(.+)')\n            .replace(/\\\\\\*/g, '([^/]+)') +\n        '$');\n    if (!fieldValue.match(regex)) {\n        return undefined;\n    }\n    return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction fieldToCamelCase(field) {\n    const parts = field.split('.');\n    return parts.map(part => (0, util_1.toCamelCase)(part)).join('.');\n}\nfunction match(request, pattern) {\n    let url = pattern;\n    const matchedFields = [];\n    for (;;) {\n        const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n        if (!match) {\n            break;\n        }\n        const [, before, field, pattern, after] = match;\n        const camelCasedField = fieldToCamelCase(field);\n        matchedFields.push(fieldToCamelCase(camelCasedField));\n        const fieldValue = getField(request, camelCasedField);\n        if (fieldValue === undefined) {\n            return undefined;\n        }\n        const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n        if (appliedPattern === undefined) {\n            return undefined;\n        }\n        url = before + appliedPattern + after;\n    }\n    return { matchedFields, url };\n}\nexports.match = match;\nfunction flattenObject(request) {\n    const result = {};\n    for (const key in request) {\n        if (request[key] === undefined) {\n            continue;\n        }\n        if (Array.isArray(request[key])) {\n            // According to the http.proto comments, a repeated field may only\n            // contain primitive types, so no extra recursion here.\n            result[key] = request[key];\n            continue;\n        }\n        if (typeof request[key] === 'object' && request[key] !== null) {\n            const nested = flattenObject(request[key]);\n            for (const nestedKey in nested) {\n                result[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n            continue;\n        }\n        result[key] = request[key];\n    }\n    return result;\n}\nexports.flattenObject = flattenObject;\nfunction isProto3OptionalField(field) {\n    return field && field.options && field.options[proto3OptionalName];\n}\nexports.isProto3OptionalField = isProto3OptionalField;\nfunction transcode(request, parsedOptions) {\n    const httpRules = [];\n    for (const option of parsedOptions) {\n        if (!(httpOptionName in option)) {\n            continue;\n        }\n        const httpRule = option[httpOptionName];\n        httpRules.push(httpRule);\n        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n            const additionalBindings = Array.isArray(httpRule.additional_bindings)\n                ? httpRule.additional_bindings\n                : [httpRule.additional_bindings];\n            httpRules.push(...additionalBindings);\n        }\n    }\n    for (const httpRule of httpRules) {\n        for (const httpMethod of supportedHttpMethods) {\n            if (!(httpMethod in httpRule)) {\n                continue;\n            }\n            const pathTemplate = httpRule[httpMethod];\n            const matchResult = match(request, pathTemplate);\n            if (matchResult === undefined) {\n                continue;\n            }\n            const { url, matchedFields } = matchResult;\n            let data = deepCopyWithoutMatchedFields(request, new Set(matchedFields));\n            if (httpRule.body === '*') {\n                return { httpMethod, url, queryString: '', data };\n            }\n            // one field possibly goes to request data, others go to query string\n            const queryStringObject = data;\n            if (httpRule.body) {\n                data = getField(queryStringObject, fieldToCamelCase(httpRule.body), \n                /*allowObjects:*/ true);\n                deleteField(queryStringObject, fieldToCamelCase(httpRule.body));\n            }\n            else {\n                data = '';\n            }\n            const queryStringComponents = buildQueryStringComponents(queryStringObject);\n            const queryString = queryStringComponents.join('&');\n            if (!data ||\n                (typeof data === 'object' && Object.keys(data).length === 0)) {\n                data = '';\n            }\n            return { httpMethod, url, queryString, data };\n        }\n    }\n    return undefined;\n}\nexports.transcode = transcode;\n// Override the protobuf json's the http rules.\nfunction overrideHttpRules(httpRules, protoJson) {\n    for (const rule of httpRules) {\n        if (!rule.selector) {\n            continue;\n        }\n        const rpc = protoJson.lookup(rule.selector);\n        // Not support override on non-exist RPC or a RPC without an annotation.\n        // We could reconsider if we have the use case later.\n        if (!rpc || !rpc.parsedOptions) {\n            continue;\n        }\n        for (const item of rpc.parsedOptions) {\n            if (!(httpOptionName in item)) {\n                continue;\n            }\n            const httpOptions = item[httpOptionName];\n            for (const httpMethod in httpOptions) {\n                if (httpMethod in rule) {\n                    if (httpMethod === 'additional_bindings') {\n                        continue;\n                    }\n                    httpOptions[httpMethod] =\n                        rule[httpMethod];\n                }\n                if (rule.additional_bindings) {\n                    httpOptions['additional_bindings'] = !httpOptions['additional_bindings']\n                        ? []\n                        : Array.isArray(httpOptions['additional_bindings'])\n                            ? httpOptions['additional_bindings']\n                            : [httpOptions['additional_bindings']];\n                    // Make the additional_binding to be an array if it is not.\n                    httpOptions['additional_bindings'].push(...rule.additional_bindings);\n                }\n            }\n        }\n    }\n}\nexports.overrideHttpRules = overrideHttpRules;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}