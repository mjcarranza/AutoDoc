{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst util_1 = require(\"./util\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n  const fullyQualifiedTypeName = typeof type === 'string' ? type : (0, util_1.getFullyQualifiedTypeName)(type);\n\n  if (typeof type !== 'string' && 'values' in type) {\n    // type is an Enum\n    if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      return 'NULL_VALUE';\n    }\n\n    return (0, enum_1.resolveEnumValueToString)(type, json);\n  }\n\n  if (typeof type !== 'string') {\n    type.resolveAll();\n  }\n\n  if (typeof type === 'string') {\n    return json;\n  } // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  // Types that can have meaningful \"null\" value\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueFromProto3JSON)(json);\n  }\n\n  if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n    if (json !== null && typeof json === 'object' || Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for ${fullyQualifiedTypeName} expects a string, a number, or a boolean, but got ${typeof json}`);\n    }\n\n    return (0, wrappers_1.wrapperFromProto3JSON)(fullyQualifiedTypeName, json);\n  }\n\n  if (json === null) {\n    return null;\n  } // Types that cannot be \"null\"\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyFromProto3JSON)(type.root, json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n    if (typeof json !== 'object') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got ${typeof json}`);\n    }\n\n    if (Array.isArray(json)) {\n      throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n    }\n\n    return (0, value_1.googleProtobufStructFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n    if (!Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got ${typeof json}`);\n    }\n\n    return (0, value_1.googleProtobufListValueFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got ${typeof json}`);\n    }\n\n    return (0, duration_1.googleProtobufDurationFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got ${typeof json}`);\n    }\n\n    return (0, timestamp_1.googleProtobufTimestampFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got ${typeof json}`);\n    }\n\n    return (0, fieldmask_1.googleProtobufFieldMaskFromProto3JSON)(json);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(json)) {\n    const field = type.fields[key];\n\n    if (!field) {\n      continue;\n    }\n\n    const resolvedType = field.resolvedType;\n    const fieldType = field.type;\n\n    if (field.repeated) {\n      if (value === null) {\n        result[key] = [];\n      } else {\n        if (!Array.isArray(value)) {\n          throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field ${key}`);\n        }\n\n        result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n      }\n    } else if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n      }\n\n      result[key] = map;\n    } else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'string') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bool') {\n      if (typeof value !== 'boolean') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bytes') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = (0, bytes_1.bytesFromProto3JSON)(value);\n    } else {\n      // Message type\n      (0, util_1.assert)(resolvedType !== null, `Expected to be able to resolve type for field ${field.name}`);\n      const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n      result[key] = deserializedValue;\n    }\n  }\n\n  return result;\n}\n\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\n\nfunction fromProto3JSON(type, json) {\n  const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n\n  if (internalRepr === null) {\n    return null;\n  } // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n\n\n  (0, util_1.assert)(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not ${json}`);\n  return type.fromObject(internalRepr);\n}\n\nexports.fromProto3JSON = fromProto3JSON;","map":{"version":3,"names":["Object","defineProperty","exports","value","fromProto3JSON","fromProto3JSONToInternalRepresentation","any_1","require","bytes_1","enum_1","value_1","util_1","duration_1","timestamp_1","wrappers_1","fieldmask_1","type","json","fullyQualifiedTypeName","getFullyQualifiedTypeName","resolveEnumValueToString","resolveAll","googleProtobufValueFromProto3JSON","wrapperTypes","has","Array","isArray","Error","wrapperFromProto3JSON","googleProtobufAnyFromProto3JSON","root","googleProtobufStructFromProto3JSON","googleProtobufListValueFromProto3JSON","googleProtobufDurationFromProto3JSON","googleProtobufTimestampFromProto3JSON","googleProtobufFieldMaskFromProto3JSON","result","key","entries","field","fields","resolvedType","fieldType","repeated","map","element","mapKey","mapValue","match","bytesFromProto3JSON","assert","name","deserializedValue","internalRepr","fromObject"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/proto3-json-serializer/build/src/fromproto3json.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\nconst any_1 = require(\"./any\");\nconst bytes_1 = require(\"./bytes\");\nconst enum_1 = require(\"./enum\");\nconst value_1 = require(\"./value\");\nconst util_1 = require(\"./util\");\nconst duration_1 = require(\"./duration\");\nconst timestamp_1 = require(\"./timestamp\");\nconst wrappers_1 = require(\"./wrappers\");\nconst fieldmask_1 = require(\"./fieldmask\");\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n    const fullyQualifiedTypeName = typeof type === 'string' ? type : (0, util_1.getFullyQualifiedTypeName)(type);\n    if (typeof type !== 'string' && 'values' in type) {\n        // type is an Enum\n        if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n            return 'NULL_VALUE';\n        }\n        return (0, enum_1.resolveEnumValueToString)(type, json);\n    }\n    if (typeof type !== 'string') {\n        type.resolveAll();\n    }\n    if (typeof type === 'string') {\n        return json;\n    }\n    // Types that require special handling according to\n    // https://developers.google.com/protocol-buffers/docs/proto3#json\n    // Types that can have meaningful \"null\" value\n    if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n        return (0, value_1.googleProtobufValueFromProto3JSON)(json);\n    }\n    if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n        if ((json !== null && typeof json === 'object') || Array.isArray(json)) {\n            throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for ${fullyQualifiedTypeName} expects a string, a number, or a boolean, but got ${typeof json}`);\n        }\n        return (0, wrappers_1.wrapperFromProto3JSON)(fullyQualifiedTypeName, json);\n    }\n    if (json === null) {\n        return null;\n    }\n    // Types that cannot be \"null\"\n    if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n        return (0, any_1.googleProtobufAnyFromProto3JSON)(type.root, json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n        if (typeof json !== 'object') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got ${typeof json}`);\n        }\n        if (Array.isArray(json)) {\n            throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n        }\n        return (0, value_1.googleProtobufStructFromProto3JSON)(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n        if (!Array.isArray(json)) {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got ${typeof json}`);\n        }\n        return (0, value_1.googleProtobufListValueFromProto3JSON)(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got ${typeof json}`);\n        }\n        return (0, duration_1.googleProtobufDurationFromProto3JSON)(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got ${typeof json}`);\n        }\n        return (0, timestamp_1.googleProtobufTimestampFromProto3JSON)(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got ${typeof json}`);\n        }\n        return (0, fieldmask_1.googleProtobufFieldMaskFromProto3JSON)(json);\n    }\n    const result = {};\n    for (const [key, value] of Object.entries(json)) {\n        const field = type.fields[key];\n        if (!field) {\n            continue;\n        }\n        const resolvedType = field.resolvedType;\n        const fieldType = field.type;\n        if (field.repeated) {\n            if (value === null) {\n                result[key] = [];\n            }\n            else {\n                if (!Array.isArray(value)) {\n                    throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field ${key}`);\n                }\n                result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n            }\n        }\n        else if (field.map) {\n            const map = {};\n            for (const [mapKey, mapValue] of Object.entries(value)) {\n                map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n            }\n            result[key] = map;\n        }\n        else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n            if (typeof value !== 'number' && typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'string') {\n            if (typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'bool') {\n            if (typeof value !== 'boolean') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'bytes') {\n            if (typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = (0, bytes_1.bytesFromProto3JSON)(value);\n        }\n        else {\n            // Message type\n            (0, util_1.assert)(resolvedType !== null, `Expected to be able to resolve type for field ${field.name}`);\n            const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n            result[key] = deserializedValue;\n        }\n    }\n    return result;\n}\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\nfunction fromProto3JSON(type, json) {\n    const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n    if (internalRepr === null) {\n        return null;\n    }\n    // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n    (0, util_1.assert)(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not ${json}`);\n    return type.fromObject(internalRepr);\n}\nexports.fromProto3JSON = fromProto3JSON;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}