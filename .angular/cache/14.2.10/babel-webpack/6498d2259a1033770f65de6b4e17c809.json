{"ast":null,"code":"\"use strict\";\n\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n  \"0\": \"\\0\",\n  \"r\": \"\\r\",\n  \"n\": \"\\n\",\n  \"t\": \"\\t\"\n};\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */\n\nfunction unescape(str) {\n  return str.replace(unescapeRe, function ($0, $1) {\n    switch ($1) {\n      case \"\\\\\":\n      case \"\":\n        return $1;\n\n      default:\n        return unescapeMap[$1] || \"\";\n    }\n  });\n}\n\ntokenize.unescape = unescape;\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */\n\n/**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */\n\n/**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */\n\n/**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */\n\n/**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */\n\nfunction tokenize(source, alternateCommentMode) {\n  /* eslint-disable callback-return */\n  source = source.toString();\n  var offset = 0,\n      length = source.length,\n      line = 1,\n      lastCommentLine = 0,\n      comments = {};\n  var stack = [];\n  var stringDelim = null;\n  /* istanbul ignore next */\n\n  /**\n   * Creates an error for illegal syntax.\n   * @param {string} subject Subject\n   * @returns {Error} Error created\n   * @inner\n   */\n\n  function illegal(subject) {\n    return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n  }\n  /**\n   * Reads a string till its end.\n   * @returns {string} String read\n   * @inner\n   */\n\n\n  function readString() {\n    var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n    re.lastIndex = offset - 1;\n    var match = re.exec(source);\n    if (!match) throw illegal(\"string\");\n    offset = re.lastIndex;\n    push(stringDelim);\n    stringDelim = null;\n    return unescape(match[1]);\n  }\n  /**\n   * Gets the character at `pos` within the source.\n   * @param {number} pos Position\n   * @returns {string} Character\n   * @inner\n   */\n\n\n  function charAt(pos) {\n    return source.charAt(pos);\n  }\n  /**\n   * Sets the current comment text.\n   * @param {number} start Start offset\n   * @param {number} end End offset\n   * @param {boolean} isLeading set if a leading comment\n   * @returns {undefined}\n   * @inner\n   */\n\n\n  function setComment(start, end, isLeading) {\n    var comment = {\n      type: source.charAt(start++),\n      lineEmpty: false,\n      leading: isLeading\n    };\n    var lookback;\n\n    if (alternateCommentMode) {\n      lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n    } else {\n      lookback = 3; // \"///\" or \"/**\"\n    }\n\n    var commentOffset = start - lookback,\n        c;\n\n    do {\n      if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n        comment.lineEmpty = true;\n        break;\n      }\n    } while (c === \" \" || c === \"\\t\");\n\n    var lines = source.substring(start, end).split(setCommentSplitRe);\n\n    for (var i = 0; i < lines.length; ++i) lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n\n    comment.text = lines.join(\"\\n\").trim();\n    comments[line] = comment;\n    lastCommentLine = line;\n  }\n\n  function isDoubleSlashCommentLine(startOffset) {\n    var endOffset = findEndOfLine(startOffset); // see if remaining line matches comment pattern\n\n    var lineText = source.substring(startOffset, endOffset);\n    var isComment = /^\\s*\\/\\//.test(lineText);\n    return isComment;\n  }\n\n  function findEndOfLine(cursor) {\n    // find end of cursor's line\n    var endOffset = cursor;\n\n    while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n      endOffset++;\n    }\n\n    return endOffset;\n  }\n  /**\n   * Obtains the next token.\n   * @returns {string|null} Next token or `null` on eof\n   * @inner\n   */\n\n\n  function next() {\n    if (stack.length > 0) return stack.shift();\n    if (stringDelim) return readString();\n    var repeat,\n        prev,\n        curr,\n        start,\n        isDoc,\n        isLeadingComment = offset === 0;\n\n    do {\n      if (offset === length) return null;\n      repeat = false;\n\n      while (whitespaceRe.test(curr = charAt(offset))) {\n        if (curr === \"\\n\") {\n          isLeadingComment = true;\n          ++line;\n        }\n\n        if (++offset === length) return null;\n      }\n\n      if (charAt(offset) === \"/\") {\n        if (++offset === length) {\n          throw illegal(\"comment\");\n        }\n\n        if (charAt(offset) === \"/\") {\n          // Line\n          if (!alternateCommentMode) {\n            // check for triple-slash comment\n            isDoc = charAt(start = offset + 1) === \"/\";\n\n            while (charAt(++offset) !== \"\\n\") {\n              if (offset === length) {\n                return null;\n              }\n            }\n\n            ++offset;\n\n            if (isDoc) {\n              setComment(start, offset - 1, isLeadingComment); // Trailing comment cannot not be multi-line,\n              // so leading comment state should be reset to handle potential next comments\n\n              isLeadingComment = true;\n            }\n\n            ++line;\n            repeat = true;\n          } else {\n            // check for double-slash comments, consolidating consecutive lines\n            start = offset;\n            isDoc = false;\n\n            if (isDoubleSlashCommentLine(offset - 1)) {\n              isDoc = true;\n\n              do {\n                offset = findEndOfLine(offset);\n\n                if (offset === length) {\n                  break;\n                }\n\n                offset++;\n\n                if (!isLeadingComment) {\n                  // Trailing comment cannot not be multi-line\n                  break;\n                }\n              } while (isDoubleSlashCommentLine(offset));\n            } else {\n              offset = Math.min(length, findEndOfLine(offset) + 1);\n            }\n\n            if (isDoc) {\n              setComment(start, offset, isLeadingComment);\n              isLeadingComment = true;\n            }\n\n            line++;\n            repeat = true;\n          }\n        } else if ((curr = charAt(offset)) === \"*\") {\n          /* Block */\n          // check for /** (regular comment mode) or /* (alternate comment mode)\n          start = offset + 1;\n          isDoc = alternateCommentMode || charAt(start) === \"*\";\n\n          do {\n            if (curr === \"\\n\") {\n              ++line;\n            }\n\n            if (++offset === length) {\n              throw illegal(\"comment\");\n            }\n\n            prev = curr;\n            curr = charAt(offset);\n          } while (prev !== \"*\" || curr !== \"/\");\n\n          ++offset;\n\n          if (isDoc) {\n            setComment(start, offset - 2, isLeadingComment);\n            isLeadingComment = true;\n          }\n\n          repeat = true;\n        } else {\n          return \"/\";\n        }\n      }\n    } while (repeat); // offset !== length if we got here\n\n\n    var end = offset;\n    delimRe.lastIndex = 0;\n    var delim = delimRe.test(charAt(end++));\n    if (!delim) while (end < length && !delimRe.test(charAt(end))) ++end;\n    var token = source.substring(offset, offset = end);\n    if (token === \"\\\"\" || token === \"'\") stringDelim = token;\n    return token;\n  }\n  /**\n   * Pushes a token back to the stack.\n   * @param {string} token Token\n   * @returns {undefined}\n   * @inner\n   */\n\n\n  function push(token) {\n    stack.push(token);\n  }\n  /**\n   * Peeks for the next token.\n   * @returns {string|null} Token or `null` on eof\n   * @inner\n   */\n\n\n  function peek() {\n    if (!stack.length) {\n      var token = next();\n      if (token === null) return null;\n      push(token);\n    }\n\n    return stack[0];\n  }\n  /**\n   * Skips a token.\n   * @param {string} expected Expected token\n   * @param {boolean} [optional=false] Whether the token is optional\n   * @returns {boolean} `true` when skipped, `false` if not\n   * @throws {Error} When a required token is not present\n   * @inner\n   */\n\n\n  function skip(expected, optional) {\n    var actual = peek(),\n        equals = actual === expected;\n\n    if (equals) {\n      next();\n      return true;\n    }\n\n    if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n    return false;\n  }\n  /**\n   * Gets a comment.\n   * @param {number} [trailingLine] Line number if looking for a trailing comment\n   * @returns {string|null} Comment text\n   * @inner\n   */\n\n\n  function cmnt(trailingLine) {\n    var ret = null;\n    var comment;\n\n    if (trailingLine === undefined) {\n      comment = comments[line - 1];\n      delete comments[line - 1];\n\n      if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n        ret = comment.leading ? comment.text : null;\n      }\n    } else {\n      /* istanbul ignore else */\n      if (lastCommentLine < trailingLine) {\n        peek();\n      }\n\n      comment = comments[trailingLine];\n      delete comments[trailingLine];\n\n      if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n        ret = comment.leading ? null : comment.text;\n      }\n    }\n\n    return ret;\n  }\n\n  return Object.defineProperty({\n    next: next,\n    peek: peek,\n    push: push,\n    skip: skip,\n    cmnt: cmnt\n  }, \"line\", {\n    get: function () {\n      return line;\n    }\n  });\n  /* eslint-enable callback-return */\n}","map":{"version":3,"names":["module","exports","tokenize","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","unescape","str","replace","$0","$1","source","alternateCommentMode","toString","offset","length","line","lastCommentLine","comments","stack","stringDelim","illegal","subject","Error","readString","re","lastIndex","match","exec","push","charAt","pos","setComment","start","end","isLeading","comment","type","lineEmpty","leading","lookback","commentOffset","c","lines","substring","split","i","trim","text","join","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","isComment","test","cursor","next","shift","repeat","prev","curr","isDoc","isLeadingComment","Math","min","delim","token","peek","skip","expected","optional","actual","equals","cmnt","trailingLine","ret","undefined","Object","defineProperty","get"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/protobufjs/src/tokenize.js"],"sourcesContent":["\"use strict\";\nmodule.exports = tokenize;\n\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\n\nvar unescapeMap = {\n    \"0\": \"\\0\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\\t\"\n};\n\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */\nfunction unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch ($1) {\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\n\ntokenize.unescape = unescape;\n\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */\n\n/**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */\n\n/**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */\n\n/**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */\n\n/**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */\nfunction tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */\n    source = source.toString();\n\n    var offset = 0,\n        length = source.length,\n        line = 1,\n        lastCommentLine = 0,\n        comments = {};\n\n    var stack = [];\n\n    var stringDelim = null;\n\n    /* istanbul ignore next */\n    /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */\n    function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */\n    function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match)\n            throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */\n    function charAt(pos) {\n        return source.charAt(pos);\n    }\n\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */\n    function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading,\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3;  // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback,\n            c;\n        do {\n            if (--commentOffset < 0 ||\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        } while (c === \" \" || c === \"\\t\");\n        var lines = source\n            .substring(start, end)\n            .split(setCommentSplitRe);\n        for (var i = 0; i < lines.length; ++i)\n            lines[i] = lines[i]\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\n                .trim();\n        comment.text = lines\n            .join(\"\\n\")\n            .trim();\n\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n            endOffset++;\n        }\n        return endOffset;\n    }\n\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */\n    function next() {\n        if (stack.length > 0)\n            return stack.shift();\n        if (stringDelim)\n            return readString();\n        var repeat,\n            prev,\n            curr,\n            start,\n            isDoc,\n            isLeadingComment = offset === 0;\n        do {\n            if (offset === length)\n                return null;\n            repeat = false;\n            while (whitespaceRe.test(curr = charAt(offset))) {\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length)\n                    return null;\n            }\n\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") { // Line\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n\n                        while (charAt(++offset) !== \"\\n\") {\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    // Trailing comment cannot not be multi-line\n                                    break;\n                                }\n                            } while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    } while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        } while (repeat);\n\n        // offset !== length if we got here\n\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim)\n            while (end < length && !delimRe.test(charAt(end)))\n                ++end;\n        var token = source.substring(offset, offset = end);\n        if (token === \"\\\"\" || token === \"'\")\n            stringDelim = token;\n        return token;\n    }\n\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */\n    function push(token) {\n        stack.push(token);\n    }\n\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */\n    function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null)\n                return null;\n            push(token);\n        }\n        return stack[0];\n    }\n\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */\n    function skip(expected, optional) {\n        var actual = peek(),\n            equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional)\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */\n    function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */\n            if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() { return line; }\n    });\n    /* eslint-enable callback-return */\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}