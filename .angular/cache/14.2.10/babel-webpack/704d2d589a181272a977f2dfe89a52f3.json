{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseProxyResponse = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');\n\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('readable', read);\n    }\n\n    function onend() {\n      cleanup();\n      debug('onend');\n      reject(new Error('Proxy connection ended before receiving CONNECT response'));\n    }\n\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\n      const firstLine = headerParts.shift();\n\n      if (!firstLine) {\n        socket.destroy();\n        return reject(new Error('No header received from proxy CONNECT response'));\n      }\n\n      const firstLineParts = firstLine.split(' ');\n      const statusCode = +firstLineParts[1];\n      const statusText = firstLineParts.slice(2).join(' ');\n      const headers = {};\n\n      for (const header of headerParts) {\n        if (!header) continue;\n        const firstColon = header.indexOf(':');\n\n        if (firstColon === -1) {\n          socket.destroy();\n          return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n        }\n\n        const key = header.slice(0, firstColon).toLowerCase();\n        const value = header.slice(firstColon + 1).trimStart();\n        const current = headers[key];\n\n        if (typeof current === 'string') {\n          headers[key] = [current, value];\n        } else if (Array.isArray(current)) {\n          current.push(value);\n        } else {\n          headers[key] = value;\n        }\n      }\n\n      debug('got proxy server response: %o %o', firstLine, headers);\n      cleanup();\n      resolve({\n        connect: {\n          statusCode,\n          statusText,\n          headers\n        },\n        buffered\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('end', onend);\n    read();\n  });\n}\n\nexports.parseProxyResponse = parseProxyResponse;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","parseProxyResponse","debug_1","require","debug","default","socket","Promise","resolve","reject","buffersLength","buffers","read","b","ondata","once","cleanup","removeListener","onend","onerror","Error","err","push","length","buffered","Buffer","concat","endOfHeaders","indexOf","headerParts","slice","toString","split","firstLine","shift","destroy","firstLineParts","statusCode","statusText","join","headers","header","firstColon","key","toLowerCase","trimStart","current","Array","isArray","connect","on"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/gaxios/node_modules/https-proxy-agent/dist/parse-proxy-response.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseProxyResponse = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('readable', read);\n        }\n        function onend() {\n            cleanup();\n            debug('onend');\n            reject(new Error('Proxy connection ended before receiving CONNECT response'));\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const headerParts = buffered\n                .slice(0, endOfHeaders)\n                .toString('ascii')\n                .split('\\r\\n');\n            const firstLine = headerParts.shift();\n            if (!firstLine) {\n                socket.destroy();\n                return reject(new Error('No header received from proxy CONNECT response'));\n            }\n            const firstLineParts = firstLine.split(' ');\n            const statusCode = +firstLineParts[1];\n            const statusText = firstLineParts.slice(2).join(' ');\n            const headers = {};\n            for (const header of headerParts) {\n                if (!header)\n                    continue;\n                const firstColon = header.indexOf(':');\n                if (firstColon === -1) {\n                    socket.destroy();\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n                }\n                const key = header.slice(0, firstColon).toLowerCase();\n                const value = header.slice(firstColon + 1).trimStart();\n                const current = headers[key];\n                if (typeof current === 'string') {\n                    headers[key] = [current, value];\n                }\n                else if (Array.isArray(current)) {\n                    current.push(value);\n                }\n                else {\n                    headers[key] = value;\n                }\n            }\n            debug('got proxy server response: %o %o', firstLine, headers);\n            cleanup();\n            resolve({\n                connect: {\n                    statusCode,\n                    statusText,\n                    headers,\n                },\n                buffered,\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.parseProxyResponse = parseProxyResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}