{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\n\nconst call_1 = require(\"../call\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst resourceCollector_1 = require(\"./resourceCollector\");\n\nclass PagedApiCaller {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n\n\n  generateParseResponseCallback(request, callback) {\n    const resourceFieldName = this.pageDescriptor.resourceField;\n    const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n    const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n    return (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!request) {\n        callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n        return;\n      }\n\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n\n      const resources = response[resourceFieldName] || [];\n      const pageToken = response[responsePageTokenFieldName];\n      let nextPageRequest = null;\n\n      if (pageToken) {\n        nextPageRequest = Object.assign({}, request);\n        nextPageRequest[requestPageTokenFieldName] = pageToken;\n      }\n\n      callback(err, resources, nextPageRequest, response);\n    };\n  }\n  /**\n   * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n   * The original gRPC call just calls callback(err, result).\n   * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n   *\n   * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n   * request, metadata, call options, and callback.\n   */\n\n\n  wrap(func) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n    };\n  }\n  /**\n   * Makes it possible to use both callback-based and promise-based calls.\n   * Returns an OngoingCall or OngoingCallPromise object.\n   * Regardless of which one is returned, it always has a `.callback` to call.\n   *\n   * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n   * @param [callback] Callback to be called, if any.\n   */\n\n\n  init(callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n\n    return new call_1.OngoingCallPromise();\n  }\n  /**\n   * Implements auto-pagination logic.\n   *\n   * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n   * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n   * accept just two parameters: (request, callback).\n   * @param request A request object that came from the user.\n   * @param settings Call settings. We are interested in `maxResults` and `autoPaginate` (they are optional).\n   * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n   * and is used to return results to the user.\n   */\n\n\n  call(apiCall, request, settings, ongoingCall) {\n    request = Object.assign({}, request);\n\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      ongoingCall.call(apiCall, request);\n      return;\n    }\n\n    const maxResults = settings.maxResults || -1;\n    const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n    resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n  }\n\n  fail(ongoingCall, err) {\n    ongoingCall.callback(err);\n  }\n\n  result(ongoingCall) {\n    return ongoingCall.promise;\n  }\n\n}\n\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"names":["Object","defineProperty","exports","value","PagedApiCaller","call_1","require","googleError_1","resourceCollector_1","constructor","pageDescriptor","generateParseResponseCallback","request","callback","resourceFieldName","resourceField","responsePageTokenFieldName","responsePageTokenField","requestPageTokenFieldName","requestPageTokenField","err","response","GoogleError","resources","pageToken","nextPageRequest","assign","wrap","func","self","wrappedCall","argument","metadata","options","init","OngoingCall","OngoingCallPromise","call","apiCall","settings","ongoingCall","autoPaginate","maxResults","resourceCollector","ResourceCollector","processAllPages","then","fail","result","promise"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/paginationCalls/pagedApiCaller.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n    /**\n     * Creates an API caller that returns a stream to performs page-streaming.\n     *\n     * @private\n     * @constructor\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\n     *   of page streaming to be performed.\n     */\n    constructor(pageDescriptor) {\n        this.pageDescriptor = pageDescriptor;\n    }\n    /**\n     * This function translates between regular gRPC calls (that accepts a request and returns a response,\n     * and does not know anything about pages and page tokens) and the users' callback (that expects\n     * to see resources from one page, a request to get the next page, and the raw response from the server).\n     *\n     * It generates a function that can be passed as a callback function to a gRPC call, will understand\n     * pagination-specific fields in the response, and call the users' callback after having those fields\n     * parsed.\n     *\n     * @param request Request object. It needs to be passed to all subsequent next page requests\n     * (the main content of the request object stays unchanged, only the next page token changes)\n     * @param callback The user's callback that expects the page content, next page request, and raw response.\n     */\n    generateParseResponseCallback(request, callback) {\n        const resourceFieldName = this.pageDescriptor.resourceField;\n        const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n        const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n        return (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (!request) {\n                callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n                return;\n            }\n            if (!response) {\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n                return;\n            }\n            const resources = response[resourceFieldName] || [];\n            const pageToken = response[responsePageTokenFieldName];\n            let nextPageRequest = null;\n            if (pageToken) {\n                nextPageRequest = Object.assign({}, request);\n                nextPageRequest[requestPageTokenFieldName] = pageToken;\n            }\n            callback(err, resources, nextPageRequest, response);\n        };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n    wrap(func) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        return function wrappedCall(argument, metadata, options, callback) {\n            return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n        };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n    init(callback) {\n        if (callback) {\n            return new call_1.OngoingCall(callback);\n        }\n        return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults` and `autoPaginate` (they are optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n    call(apiCall, request, settings, ongoingCall) {\n        request = Object.assign({}, request);\n        if (!settings.autoPaginate) {\n            // they don't want auto-pagination this time - okay, just call once\n            ongoingCall.call(apiCall, request);\n            return;\n        }\n        const maxResults = settings.maxResults || -1;\n        const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n        resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n    }\n    fail(ongoingCall, err) {\n        ongoingCall.callback(err);\n    }\n    result(ongoingCall) {\n        return ongoingCall.promise;\n    }\n}\nexports.PagedApiCaller = PagedApiCaller;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}