{"ast":null,"code":"\"use strict\"; // Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRetryConfig = void 0;\n\nfunction getRetryConfig(_x) {\n  return _getRetryConfig.apply(this, arguments);\n}\n\nfunction _getRetryConfig() {\n  _getRetryConfig = _asyncToGenerator(function* (err) {\n    var _a;\n\n    let config = getConfig(err);\n\n    if (!err || !err.config || !config && !err.config.retry) {\n      return {\n        shouldRetry: false\n      };\n    }\n\n    config = config || {};\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;\n    config.httpMethodsToRetry = config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];\n    config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries; // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n\n    const retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n    // 1xx - Retry (Informational, request still processing)\n    // 2xx - Do not retry (Success)\n    // 3xx - Do not retry (Redirect)\n    // 4xx - Do not retry (Client errors)\n    // 429 - Retry (\"Too Many Requests\")\n    // 5xx - Retry (Server errors)\n    [100, 199], [429, 429], [500, 599]];\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges; // Put the config back into the err\n\n    err.config.retryConfig = config; // Determine if we should retry the request\n\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n\n    if (!(yield shouldRetryFn(err))) {\n      return {\n        shouldRetry: false,\n        config: err.config\n      };\n    } // Calculate time to wait with exponential backoff.\n    // If this is the first retry, look for a configured retryDelay.\n\n\n    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100; // Formula: retryDelay + ((2^c - 1 / 2) * 1000)\n\n    const delay = retryDelay + (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000; // We're going to retry!  Incremenent the counter.\n\n    err.config.retryConfig.currentRetryAttempt += 1; // Create a promise that invokes the retry after the backOffDelay\n\n    const backoff = config.retryBackoff ? config.retryBackoff(err, delay) : new Promise(resolve => {\n      setTimeout(resolve, delay);\n    }); // Notify the user if they added an `onRetryAttempt` handler\n\n    if (config.onRetryAttempt) {\n      config.onRetryAttempt(err);\n    } // Return the promise in which recalls Gaxios to retry the request\n\n\n    yield backoff;\n    return {\n      shouldRetry: true,\n      config: err.config\n    };\n  });\n  return _getRetryConfig.apply(this, arguments);\n}\n\nexports.getRetryConfig = getRetryConfig;\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\n\nfunction shouldRetryRequest(err) {\n  var _a;\n\n  const config = getConfig(err); // node-fetch raises an AbortError if signaled:\n  // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal\n\n  if (err.name === 'AbortError' || ((_a = err.error) === null || _a === void 0 ? void 0 : _a.name) === 'AbortError') {\n    return false;\n  } // If there's no config, or retries are disabled, return.\n\n\n  if (!config || config.retry === 0) {\n    return false;\n  } // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n\n\n  if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n    return false;\n  } // Only retry with configured HttpMethods.\n\n\n  if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n    return false;\n  } // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n\n  if (err.response && err.response.status) {\n    let isInRange = false;\n\n    for (const [min, max] of config.statusCodesToRetry) {\n      const status = err.response.status;\n\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n\n    if (!isInRange) {\n      return false;\n    }\n  } // If we are out of retry attempts, return\n\n\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n\n  if (config.currentRetryAttempt >= config.retry) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\n\n\nfunction getConfig(err) {\n  if (err && err.config && err.config.retryConfig) {\n    return err.config.retryConfig;\n  }\n\n  return;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getRetryConfig","err","_a","config","getConfig","retry","shouldRetry","currentRetryAttempt","undefined","httpMethodsToRetry","noResponseRetries","retryRanges","statusCodesToRetry","retryConfig","shouldRetryFn","shouldRetryRequest","retryDelay","delay","Math","pow","backoff","retryBackoff","Promise","resolve","setTimeout","onRetryAttempt","name","error","response","method","indexOf","toUpperCase","status","isInRange","min","max"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/gaxios/build/src/retry.js"],"sourcesContent":["\"use strict\";\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRetryConfig = void 0;\nasync function getRetryConfig(err) {\n    var _a;\n    let config = getConfig(err);\n    if (!err || !err.config || (!config && !err.config.retry)) {\n        return { shouldRetry: false };\n    }\n    config = config || {};\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    config.retry =\n        config.retry === undefined || config.retry === null ? 3 : config.retry;\n    config.httpMethodsToRetry = config.httpMethodsToRetry || [\n        'GET',\n        'HEAD',\n        'PUT',\n        'OPTIONS',\n        'DELETE',\n    ];\n    config.noResponseRetries =\n        config.noResponseRetries === undefined || config.noResponseRetries === null\n            ? 2\n            : config.noResponseRetries;\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    const retryRanges = [\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        // 1xx - Retry (Informational, request still processing)\n        // 2xx - Do not retry (Success)\n        // 3xx - Do not retry (Redirect)\n        // 4xx - Do not retry (Client errors)\n        // 429 - Retry (\"Too Many Requests\")\n        // 5xx - Retry (Server errors)\n        [100, 199],\n        [429, 429],\n        [500, 599],\n    ];\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\n    // Put the config back into the err\n    err.config.retryConfig = config;\n    // Determine if we should retry the request\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n    if (!(await shouldRetryFn(err))) {\n        return { shouldRetry: false, config: err.config };\n    }\n    // Calculate time to wait with exponential backoff.\n    // If this is the first retry, look for a configured retryDelay.\n    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100;\n    // Formula: retryDelay + ((2^c - 1 / 2) * 1000)\n    const delay = retryDelay + ((Math.pow(2, config.currentRetryAttempt) - 1) / 2) * 1000;\n    // We're going to retry!  Incremenent the counter.\n    err.config.retryConfig.currentRetryAttempt += 1;\n    // Create a promise that invokes the retry after the backOffDelay\n    const backoff = config.retryBackoff\n        ? config.retryBackoff(err, delay)\n        : new Promise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    // Notify the user if they added an `onRetryAttempt` handler\n    if (config.onRetryAttempt) {\n        config.onRetryAttempt(err);\n    }\n    // Return the promise in which recalls Gaxios to retry the request\n    await backoff;\n    return { shouldRetry: true, config: err.config };\n}\nexports.getRetryConfig = getRetryConfig;\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\nfunction shouldRetryRequest(err) {\n    var _a;\n    const config = getConfig(err);\n    // node-fetch raises an AbortError if signaled:\n    // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal\n    if (err.name === 'AbortError' || ((_a = err.error) === null || _a === void 0 ? void 0 : _a.name) === 'AbortError') {\n        return false;\n    }\n    // If there's no config, or retries are disabled, return.\n    if (!config || config.retry === 0) {\n        return false;\n    }\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n    if (!err.response &&\n        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n        return false;\n    }\n    // Only retry with configured HttpMethods.\n    if (!err.config.method ||\n        config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n        return false;\n    }\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    if (err.response && err.response.status) {\n        let isInRange = false;\n        for (const [min, max] of config.statusCodesToRetry) {\n            const status = err.response.status;\n            if (status >= min && status <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        if (!isInRange) {\n            return false;\n        }\n    }\n    // If we are out of retry attempts, return\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    if (config.currentRetryAttempt >= config.retry) {\n        return false;\n    }\n    return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\nfunction getConfig(err) {\n    if (err && err.config && err.config.retryConfig) {\n        return err.config.retryConfig;\n    }\n    return;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}