{"ast":null,"code":"\"use strict\";\n/**\n * Various utility functions.\n * @namespace\n */\n\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\nEnum;\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch = require(\"@protobufjs/fetch\");\nutil.path = require(\"@protobufjs/path\");\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\n\nutil.fs = util.inquire(\"fs\");\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\n\nutil.toArray = function toArray(object) {\n  if (object) {\n    var keys = Object.keys(object),\n        array = new Array(keys.length),\n        index = 0;\n\n    while (index < keys.length) array[index] = object[keys[index++]];\n\n    return array;\n  }\n\n  return [];\n};\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\n\n\nutil.toObject = function toObject(array) {\n  var object = {},\n      index = 0;\n\n  while (index < array.length) {\n    var key = array[index++],\n        val = array[index++];\n    if (val !== undefined) object[key] = val;\n  }\n\n  return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe = /\"/g;\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\n\nutil.isReserved = function isReserved(name) {\n  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\n\n\nutil.safeProp = function safeProp(prop) {\n  if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n  return \".\" + prop;\n};\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\n\n\nutil.ucFirst = function ucFirst(str) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\n\nutil.camelCase = function camelCase(str) {\n  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\n\n\nutil.compareFieldsById = function compareFieldsById(a, b) {\n  return a.id - b.id;\n};\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\n\n\nutil.decorateType = function decorateType(ctor, typeName) {\n  /* istanbul ignore if */\n  if (ctor.$type) {\n    if (typeName && ctor.$type.name !== typeName) {\n      util.decorateRoot.remove(ctor.$type);\n      ctor.$type.name = typeName;\n      util.decorateRoot.add(ctor.$type);\n    }\n\n    return ctor.$type;\n  }\n  /* istanbul ignore next */\n\n\n  if (!Type) Type = require(\"./type\");\n  var type = new Type(typeName || ctor.name);\n  util.decorateRoot.add(type);\n  type.ctor = ctor; // sets up .encode, .decode etc.\n\n  Object.defineProperty(ctor, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  Object.defineProperty(ctor.prototype, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  return type;\n};\n\nvar decorateEnumIndex = 0;\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\n\nutil.decorateEnum = function decorateEnum(object) {\n  /* istanbul ignore if */\n  if (object.$type) return object.$type;\n  /* istanbul ignore next */\n\n  if (!Enum) Enum = require(\"./enum\");\n  var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n  util.decorateRoot.add(enm);\n  Object.defineProperty(object, \"$type\", {\n    value: enm,\n    enumerable: false\n  });\n  return enm;\n};\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\n\n\nutil.setProperty = function setProperty(dst, path, value) {\n  function setProp(dst, path, value) {\n    var part = path.shift();\n\n    if (part === \"__proto__\" || part === \"prototype\") {\n      return dst;\n    }\n\n    if (path.length > 0) {\n      dst[part] = setProp(dst[part] || {}, path, value);\n    } else {\n      var prevValue = dst[part];\n      if (prevValue) value = [].concat(prevValue).concat(value);\n      dst[part] = value;\n    }\n\n    return dst;\n  }\n\n  if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n  if (!path) throw TypeError(\"path must be specified\");\n  path = path.split(\".\");\n  return setProp(dst, path, value);\n};\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\n\n\nObject.defineProperty(util, \"decorateRoot\", {\n  get: function () {\n    return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n  }\n});","map":{"version":3,"names":["util","module","exports","require","roots","Type","Enum","codegen","fetch","path","fs","inquire","toArray","object","keys","Object","array","Array","length","index","toObject","key","val","undefined","safePropBackslashRe","safePropQuoteRe","isReserved","name","test","safeProp","prop","replace","ucFirst","str","charAt","toUpperCase","substring","camelCaseRe","camelCase","$0","$1","compareFieldsById","a","b","id","decorateType","ctor","typeName","$type","decorateRoot","remove","add","type","defineProperty","value","enumerable","prototype","decorateEnumIndex","decorateEnum","enm","setProperty","dst","setProp","part","shift","prevValue","concat","TypeError","split","get"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/protobufjs/src/util.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch   = require(\"@protobufjs/fetch\");\nutil.path    = require(\"@protobufjs/path\");\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(\"./type\");\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(\"./enum\");\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n    }\n});\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,IAAIA,IAAI,GAAGC,MAAM,CAACC,OAAP,GAAiBC,OAAO,CAAC,gBAAD,CAAnC;;AAEA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;;AAEA,IAAIE,IAAJ,EAAU;AACNC,IADJ;AAGAN,IAAI,CAACO,OAAL,GAAeJ,OAAO,CAAC,qBAAD,CAAtB;AACAH,IAAI,CAACQ,KAAL,GAAeL,OAAO,CAAC,mBAAD,CAAtB;AACAH,IAAI,CAACS,IAAL,GAAeN,OAAO,CAAC,kBAAD,CAAtB;AAEA;AACA;AACA;AACA;;AACAH,IAAI,CAACU,EAAL,GAAUV,IAAI,CAACW,OAAL,CAAa,IAAb,CAAV;AAEA;AACA;AACA;AACA;AACA;;AACAX,IAAI,CAACY,OAAL,GAAe,SAASA,OAAT,CAAiBC,MAAjB,EAAyB;EACpC,IAAIA,MAAJ,EAAY;IACR,IAAIC,IAAI,GAAIC,MAAM,CAACD,IAAP,CAAYD,MAAZ,CAAZ;IAAA,IACIG,KAAK,GAAG,IAAIC,KAAJ,CAAUH,IAAI,CAACI,MAAf,CADZ;IAAA,IAEIC,KAAK,GAAG,CAFZ;;IAGA,OAAOA,KAAK,GAAGL,IAAI,CAACI,MAApB,EACIF,KAAK,CAACG,KAAD,CAAL,GAAeN,MAAM,CAACC,IAAI,CAACK,KAAK,EAAN,CAAL,CAArB;;IACJ,OAAOH,KAAP;EACH;;EACD,OAAO,EAAP;AACH,CAVD;AAYA;AACA;AACA;AACA;AACA;;;AACAhB,IAAI,CAACoB,QAAL,GAAgB,SAASA,QAAT,CAAkBJ,KAAlB,EAAyB;EACrC,IAAIH,MAAM,GAAG,EAAb;EAAA,IACIM,KAAK,GAAI,CADb;;EAEA,OAAOA,KAAK,GAAGH,KAAK,CAACE,MAArB,EAA6B;IACzB,IAAIG,GAAG,GAAGL,KAAK,CAACG,KAAK,EAAN,CAAf;IAAA,IACIG,GAAG,GAAGN,KAAK,CAACG,KAAK,EAAN,CADf;IAEA,IAAIG,GAAG,KAAKC,SAAZ,EACIV,MAAM,CAACQ,GAAD,CAAN,GAAcC,GAAd;EACP;;EACD,OAAOT,MAAP;AACH,CAVD;;AAYA,IAAIW,mBAAmB,GAAG,KAA1B;AAAA,IACIC,eAAe,GAAO,IAD1B;AAGA;AACA;AACA;AACA;AACA;;AACAzB,IAAI,CAAC0B,UAAL,GAAkB,SAASA,UAAT,CAAoBC,IAApB,EAA0B;EACxC,OAAO,uTAAuTC,IAAvT,CAA4TD,IAA5T,CAAP;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA3B,IAAI,CAAC6B,QAAL,GAAgB,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;EACpC,IAAI,CAAC,YAAYF,IAAZ,CAAiBE,IAAjB,CAAD,IAA2B9B,IAAI,CAAC0B,UAAL,CAAgBI,IAAhB,CAA/B,EACI,OAAO,QAAQA,IAAI,CAACC,OAAL,CAAaP,mBAAb,EAAkC,MAAlC,EAA0CO,OAA1C,CAAkDN,eAAlD,EAAmE,MAAnE,CAAR,GAAqF,KAA5F;EACJ,OAAO,MAAMK,IAAb;AACH,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA9B,IAAI,CAACgC,OAAL,GAAe,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;EACjC,OAAOA,GAAG,CAACC,MAAJ,CAAW,CAAX,EAAcC,WAAd,KAA8BF,GAAG,CAACG,SAAJ,CAAc,CAAd,CAArC;AACH,CAFD;;AAIA,IAAIC,WAAW,GAAG,WAAlB;AAEA;AACA;AACA;AACA;AACA;;AACArC,IAAI,CAACsC,SAAL,GAAiB,SAASA,SAAT,CAAmBL,GAAnB,EAAwB;EACrC,OAAOA,GAAG,CAACG,SAAJ,CAAc,CAAd,EAAiB,CAAjB,IACAH,GAAG,CAACG,SAAJ,CAAc,CAAd,EACKL,OADL,CACaM,WADb,EAC0B,UAASE,EAAT,EAAaC,EAAb,EAAiB;IAAE,OAAOA,EAAE,CAACL,WAAH,EAAP;EAA0B,CADvE,CADP;AAGH,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;;;AACAnC,IAAI,CAACyC,iBAAL,GAAyB,SAASA,iBAAT,CAA2BC,CAA3B,EAA8BC,CAA9B,EAAiC;EACtD,OAAOD,CAAC,CAACE,EAAF,GAAOD,CAAC,CAACC,EAAhB;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA5C,IAAI,CAAC6C,YAAL,GAAoB,SAASA,YAAT,CAAsBC,IAAtB,EAA4BC,QAA5B,EAAsC;EAEtD;EACA,IAAID,IAAI,CAACE,KAAT,EAAgB;IACZ,IAAID,QAAQ,IAAID,IAAI,CAACE,KAAL,CAAWrB,IAAX,KAAoBoB,QAApC,EAA8C;MAC1C/C,IAAI,CAACiD,YAAL,CAAkBC,MAAlB,CAAyBJ,IAAI,CAACE,KAA9B;MACAF,IAAI,CAACE,KAAL,CAAWrB,IAAX,GAAkBoB,QAAlB;MACA/C,IAAI,CAACiD,YAAL,CAAkBE,GAAlB,CAAsBL,IAAI,CAACE,KAA3B;IACH;;IACD,OAAOF,IAAI,CAACE,KAAZ;EACH;EAED;;;EACA,IAAI,CAAC3C,IAAL,EACIA,IAAI,GAAGF,OAAO,CAAC,QAAD,CAAd;EAEJ,IAAIiD,IAAI,GAAG,IAAI/C,IAAJ,CAAS0C,QAAQ,IAAID,IAAI,CAACnB,IAA1B,CAAX;EACA3B,IAAI,CAACiD,YAAL,CAAkBE,GAAlB,CAAsBC,IAAtB;EACAA,IAAI,CAACN,IAAL,GAAYA,IAAZ,CAlBsD,CAkBpC;;EAClB/B,MAAM,CAACsC,cAAP,CAAsBP,IAAtB,EAA4B,OAA5B,EAAqC;IAAEQ,KAAK,EAAEF,IAAT;IAAeG,UAAU,EAAE;EAA3B,CAArC;EACAxC,MAAM,CAACsC,cAAP,CAAsBP,IAAI,CAACU,SAA3B,EAAsC,OAAtC,EAA+C;IAAEF,KAAK,EAAEF,IAAT;IAAeG,UAAU,EAAE;EAA3B,CAA/C;EACA,OAAOH,IAAP;AACH,CAtBD;;AAwBA,IAAIK,iBAAiB,GAAG,CAAxB;AAEA;AACA;AACA;AACA;AACA;;AACAzD,IAAI,CAAC0D,YAAL,GAAoB,SAASA,YAAT,CAAsB7C,MAAtB,EAA8B;EAE9C;EACA,IAAIA,MAAM,CAACmC,KAAX,EACI,OAAOnC,MAAM,CAACmC,KAAd;EAEJ;;EACA,IAAI,CAAC1C,IAAL,EACIA,IAAI,GAAGH,OAAO,CAAC,QAAD,CAAd;EAEJ,IAAIwD,GAAG,GAAG,IAAIrD,IAAJ,CAAS,SAASmD,iBAAiB,EAAnC,EAAuC5C,MAAvC,CAAV;EACAb,IAAI,CAACiD,YAAL,CAAkBE,GAAlB,CAAsBQ,GAAtB;EACA5C,MAAM,CAACsC,cAAP,CAAsBxC,MAAtB,EAA8B,OAA9B,EAAuC;IAAEyC,KAAK,EAAEK,GAAT;IAAcJ,UAAU,EAAE;EAA1B,CAAvC;EACA,OAAOI,GAAP;AACH,CAdD;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3D,IAAI,CAAC4D,WAAL,GAAmB,SAASA,WAAT,CAAqBC,GAArB,EAA0BpD,IAA1B,EAAgC6C,KAAhC,EAAuC;EACtD,SAASQ,OAAT,CAAiBD,GAAjB,EAAsBpD,IAAtB,EAA4B6C,KAA5B,EAAmC;IAC/B,IAAIS,IAAI,GAAGtD,IAAI,CAACuD,KAAL,EAAX;;IACA,IAAID,IAAI,KAAK,WAAT,IAAwBA,IAAI,KAAK,WAArC,EAAkD;MAChD,OAAOF,GAAP;IACD;;IACD,IAAIpD,IAAI,CAACS,MAAL,GAAc,CAAlB,EAAqB;MACjB2C,GAAG,CAACE,IAAD,CAAH,GAAYD,OAAO,CAACD,GAAG,CAACE,IAAD,CAAH,IAAa,EAAd,EAAkBtD,IAAlB,EAAwB6C,KAAxB,CAAnB;IACH,CAFD,MAEO;MACH,IAAIW,SAAS,GAAGJ,GAAG,CAACE,IAAD,CAAnB;MACA,IAAIE,SAAJ,EACIX,KAAK,GAAG,GAAGY,MAAH,CAAUD,SAAV,EAAqBC,MAArB,CAA4BZ,KAA5B,CAAR;MACJO,GAAG,CAACE,IAAD,CAAH,GAAYT,KAAZ;IACH;;IACD,OAAOO,GAAP;EACH;;EAED,IAAI,OAAOA,GAAP,KAAe,QAAnB,EACI,MAAMM,SAAS,CAAC,uBAAD,CAAf;EACJ,IAAI,CAAC1D,IAAL,EACI,MAAM0D,SAAS,CAAC,wBAAD,CAAf;EAEJ1D,IAAI,GAAGA,IAAI,CAAC2D,KAAL,CAAW,GAAX,CAAP;EACA,OAAON,OAAO,CAACD,GAAD,EAAMpD,IAAN,EAAY6C,KAAZ,CAAd;AACH,CAxBD;AA0BA;AACA;AACA;AACA;AACA;AACA;;;AACAvC,MAAM,CAACsC,cAAP,CAAsBrD,IAAtB,EAA4B,cAA5B,EAA4C;EACxCqE,GAAG,EAAE,YAAW;IACZ,OAAOjE,KAAK,CAAC,WAAD,CAAL,KAAuBA,KAAK,CAAC,WAAD,CAAL,GAAqB,KAAKD,OAAO,CAAC,QAAD,CAAZ,GAA5C,CAAP;EACH;AAHuC,CAA5C"},"metadata":{},"sourceType":"script"}