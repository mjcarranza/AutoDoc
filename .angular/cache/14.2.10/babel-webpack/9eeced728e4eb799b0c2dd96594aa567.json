{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PageDescriptor = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\n\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\n\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\n\nclass PageDescriptor {\n  constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n    this.requestPageTokenField = requestPageTokenField;\n    this.responsePageTokenField = responsePageTokenField;\n    this.resourceField = resourceField;\n  }\n  /**\n   * Creates a new object Stream which emits the resource on 'data' event.\n   */\n\n\n  createStream(apiCall, request, options) {\n    const stream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const maxResults = 'maxResults' in options ? options.maxResults : -1;\n    let pushCount = 0;\n    let started = false;\n\n    function callback(err, resources, next, apiResp) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      } // emit full api response with every page.\n\n\n      stream.emit('response', apiResp);\n\n      for (let i = 0; i < resources.length; ++i) {\n        // TODO: rewrite without accessing stream internals\n        if (stream._readableState.ended) {\n          return;\n        }\n\n        if (resources[i] === null) {\n          continue;\n        }\n\n        stream.push(resources[i]);\n        pushCount++;\n\n        if (pushCount === maxResults) {\n          stream.end();\n        }\n      } // TODO: rewrite without accessing stream internals\n\n\n      if (stream._readableState.ended) {\n        return;\n      }\n\n      if (!next) {\n        stream.end();\n        return;\n      } // When pageToken is specified in the original options, it will overwrite\n      // the page token field in the next request. Therefore it must be cleared.\n\n\n      if ('pageToken' in options) {\n        delete options.pageToken;\n      }\n\n      if (stream.isPaused()) {\n        request = next;\n        started = false;\n      } else {\n        setImmediate(apiCall, next, options, callback);\n      }\n    }\n\n    stream.on('resume', () => {\n      if (!started) {\n        started = true;\n        apiCall(request, options, callback);\n      }\n    });\n    return stream;\n  }\n  /**\n   * Create an async iterable which can be recursively called for data on-demand.\n   */\n\n\n  asyncIterate(apiCall, request, options) {\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const iterable = this.createIterator(apiCall, request, options);\n    return iterable;\n  }\n\n  createIterator(apiCall, request, options) {\n    const asyncIterable = {\n      [Symbol.asyncIterator]() {\n        let nextPageRequest = request;\n        const cache = [];\n        return {\n          next() {\n            return _asyncToGenerator(function* () {\n              if (cache.length > 0) {\n                return Promise.resolve({\n                  done: false,\n                  value: cache.shift()\n                });\n              }\n\n              let attempts = 0;\n\n              while (cache.length === 0 && nextPageRequest) {\n                let result;\n                [result, nextPageRequest] = yield apiCall(nextPageRequest, options); // For pagination response with protobuf map type, use tuple as representation.\n\n                if (result && !Array.isArray(result)) {\n                  for (const [key, value] of Object.entries(result)) {\n                    cache.push([key, value]);\n                  }\n                } else {\n                  cache.push(...result);\n                }\n\n                if (cache.length === 0) {\n                  ++attempts;\n\n                  if (attempts > maxAttemptsEmptyResponse) {\n                    break;\n                  }\n                }\n              }\n\n              if (cache.length === 0) {\n                return Promise.resolve({\n                  done: true,\n                  value: undefined\n                });\n              }\n\n              return Promise.resolve({\n                done: false,\n                value: cache.shift()\n              });\n            })();\n          }\n\n        };\n      }\n\n    };\n    return asyncIterable;\n  }\n\n  getApiCaller(settings) {\n    if (!settings.autoPaginate) {\n      return new normalApiCaller_1.NormalApiCaller();\n    }\n\n    return new pagedApiCaller_1.PagedApiCaller(this);\n  }\n\n}\n\nexports.PageDescriptor = PageDescriptor;","map":{"version":3,"names":["Object","defineProperty","exports","value","PageDescriptor","stream_1","require","normalApiCaller_1","pagedApiCaller_1","maxAttemptsEmptyResponse","constructor","requestPageTokenField","responsePageTokenField","resourceField","createStream","apiCall","request","options","stream","PassThrough","objectMode","assign","autoPaginate","maxResults","pushCount","started","callback","err","resources","next","apiResp","emit","i","length","_readableState","ended","push","end","pageToken","isPaused","setImmediate","on","asyncIterate","iterable","createIterator","asyncIterable","Symbol","asyncIterator","nextPageRequest","cache","Promise","resolve","done","shift","attempts","result","Array","isArray","key","entries","undefined","getApiCaller","settings","NormalApiCaller","PagedApiCaller"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/paginationCalls/pageDescriptor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PageDescriptor = void 0;\nconst stream_1 = require(\"stream\");\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\nclass PageDescriptor {\n    constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n        this.requestPageTokenField = requestPageTokenField;\n        this.responsePageTokenField = responsePageTokenField;\n        this.resourceField = resourceField;\n    }\n    /**\n     * Creates a new object Stream which emits the resource on 'data' event.\n     */\n    createStream(apiCall, request, options) {\n        const stream = new stream_1.PassThrough({ objectMode: true });\n        options = Object.assign({}, options, { autoPaginate: false });\n        const maxResults = 'maxResults' in options ? options.maxResults : -1;\n        let pushCount = 0;\n        let started = false;\n        function callback(err, resources, next, apiResp) {\n            if (err) {\n                stream.emit('error', err);\n                return;\n            }\n            // emit full api response with every page.\n            stream.emit('response', apiResp);\n            for (let i = 0; i < resources.length; ++i) {\n                // TODO: rewrite without accessing stream internals\n                if (stream\n                    ._readableState.ended) {\n                    return;\n                }\n                if (resources[i] === null) {\n                    continue;\n                }\n                stream.push(resources[i]);\n                pushCount++;\n                if (pushCount === maxResults) {\n                    stream.end();\n                }\n            }\n            // TODO: rewrite without accessing stream internals\n            if (stream._readableState\n                .ended) {\n                return;\n            }\n            if (!next) {\n                stream.end();\n                return;\n            }\n            // When pageToken is specified in the original options, it will overwrite\n            // the page token field in the next request. Therefore it must be cleared.\n            if ('pageToken' in options) {\n                delete options.pageToken;\n            }\n            if (stream.isPaused()) {\n                request = next;\n                started = false;\n            }\n            else {\n                setImmediate(apiCall, next, options, callback);\n            }\n        }\n        stream.on('resume', () => {\n            if (!started) {\n                started = true;\n                apiCall(request, options, callback);\n            }\n        });\n        return stream;\n    }\n    /**\n     * Create an async iterable which can be recursively called for data on-demand.\n     */\n    asyncIterate(apiCall, request, options) {\n        options = Object.assign({}, options, { autoPaginate: false });\n        const iterable = this.createIterator(apiCall, request, options);\n        return iterable;\n    }\n    createIterator(apiCall, request, options) {\n        const asyncIterable = {\n            [Symbol.asyncIterator]() {\n                let nextPageRequest = request;\n                const cache = [];\n                return {\n                    async next() {\n                        if (cache.length > 0) {\n                            return Promise.resolve({\n                                done: false,\n                                value: cache.shift(),\n                            });\n                        }\n                        let attempts = 0;\n                        while (cache.length === 0 && nextPageRequest) {\n                            let result;\n                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));\n                            // For pagination response with protobuf map type, use tuple as representation.\n                            if (result && !Array.isArray(result)) {\n                                for (const [key, value] of Object.entries(result)) {\n                                    cache.push([key, value]);\n                                }\n                            }\n                            else {\n                                cache.push(...result);\n                            }\n                            if (cache.length === 0) {\n                                ++attempts;\n                                if (attempts > maxAttemptsEmptyResponse) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (cache.length === 0) {\n                            return Promise.resolve({ done: true, value: undefined });\n                        }\n                        return Promise.resolve({ done: false, value: cache.shift() });\n                    },\n                };\n            },\n        };\n        return asyncIterable;\n    }\n    getApiCaller(settings) {\n        if (!settings.autoPaginate) {\n            return new normalApiCaller_1.NormalApiCaller();\n        }\n        return new pagedApiCaller_1.PagedApiCaller(this);\n    }\n}\nexports.PageDescriptor = PageDescriptor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}