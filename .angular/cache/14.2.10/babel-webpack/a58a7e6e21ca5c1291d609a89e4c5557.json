{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n\n/* global AbortController */\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst featureDetection_1 = require(\"./featureDetection\");\n\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\n\nconst stream_1 = require(\"stream\");\n\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n  const fetch = (0, featureDetection_1.hasWindowFetch)() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      options !== null && options !== void 0 ? options : options = {}; // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n\n      let fetchParameters;\n\n      try {\n        fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n      } catch (err) {\n        // we could not encode parameters; pass error to the callback\n        // and return a no-op canceler object.\n        if (callback) {\n          callback(err);\n        }\n\n        return {\n          cancel() {}\n\n        };\n      }\n\n      const cancelController = (0, featureDetection_1.hasAbortController)() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: { ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n\n        if (fetchParameters.method === 'GET' || fetchParameters.method === 'DELETE') {\n          delete fetchRequest['body'];\n        }\n\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          (0, stream_1.pipeline)(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(([ok, buffer]) => {\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              if (rpc.responseStream) {\n                if (callback) {\n                  callback(err);\n                }\n\n                streamArrayParser.emit('error', err);\n              } else if (callback) {\n                callback(err);\n              } else {\n                throw err;\n              }\n            }\n          });\n        }\n      }).catch(err => {\n        if (rpc.responseStream) {\n          if (callback) {\n            callback(err);\n          }\n\n          streamArrayParser.emit('error', err);\n        } else if (callback) {\n          callback(err);\n        } else {\n          throw err;\n        }\n      });\n\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n\n  return serviceStub;\n}\n\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"names":["Object","defineProperty","exports","value","generateServiceStub","node_fetch_1","require","abort_controller_1","featureDetection_1","streamArrayParser_1","stream_1","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","numericEnums","fetch","hasWindowFetch","window","default","serviceStub","close","cancel","rpcName","rpc","entries","request","options","_metadata","callback","fetchParameters","err","cancelController","hasAbortController","AbortController","cancelSignal","signal","cancelRequested","url","headers","key","keys","streamArrayParser","StreamArrayParser","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","pipeline","Error","name","emit","Promise","all","resolve","arrayBuffer","buffer","catch","abort"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/fallbackServiceStub.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateServiceStub = void 0;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n    const fetch = (0, featureDetection_1.hasWindowFetch)()\n        ? window.fetch\n        : node_fetch_1.default;\n    const serviceStub = {\n        // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n        close: () => {\n            return { cancel: () => { } };\n        },\n    };\n    for (const [rpcName, rpc] of Object.entries(rpcs)) {\n        serviceStub[rpcName] = (request, options, _metadata, callback) => {\n            options !== null && options !== void 0 ? options : (options = {});\n            // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n            // Using plain old promises instead.\n            let fetchParameters;\n            try {\n                fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n            }\n            catch (err) {\n                // we could not encode parameters; pass error to the callback\n                // and return a no-op canceler object.\n                if (callback) {\n                    callback(err);\n                }\n                return {\n                    cancel() { },\n                };\n            }\n            const cancelController = (0, featureDetection_1.hasAbortController)()\n                ? new AbortController()\n                : new abort_controller_1.AbortController();\n            const cancelSignal = cancelController.signal;\n            let cancelRequested = false;\n            const url = fetchParameters.url;\n            const headers = fetchParameters.headers;\n            for (const key of Object.keys(options)) {\n                headers[key] = options[key][0];\n            }\n            const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n            authClient\n                .getRequestHeaders()\n                .then(authHeader => {\n                const fetchRequest = {\n                    headers: {\n                        ...authHeader,\n                        ...headers,\n                    },\n                    body: fetchParameters.body,\n                    method: fetchParameters.method,\n                    signal: cancelSignal,\n                };\n                if (fetchParameters.method === 'GET' ||\n                    fetchParameters.method === 'DELETE') {\n                    delete fetchRequest['body'];\n                }\n                return fetch(url, fetchRequest);\n            })\n                .then((response) => {\n                if (response.ok && rpc.responseStream) {\n                    (0, stream_1.pipeline)(response.body, streamArrayParser, (err) => {\n                        if (err &&\n                            (!cancelRequested ||\n                                (err instanceof Error && err.name !== 'AbortError'))) {\n                            if (callback) {\n                                callback(err);\n                            }\n                            streamArrayParser.emit('error', err);\n                        }\n                    });\n                    return;\n                }\n                else {\n                    return Promise.all([\n                        Promise.resolve(response.ok),\n                        response.arrayBuffer(),\n                    ])\n                        .then(([ok, buffer]) => {\n                        const response = responseDecoder(rpc, ok, buffer);\n                        callback(null, response);\n                    })\n                        .catch((err) => {\n                        if (!cancelRequested || err.name !== 'AbortError') {\n                            if (rpc.responseStream) {\n                                if (callback) {\n                                    callback(err);\n                                }\n                                streamArrayParser.emit('error', err);\n                            }\n                            else if (callback) {\n                                callback(err);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    });\n                }\n            })\n                .catch((err) => {\n                if (rpc.responseStream) {\n                    if (callback) {\n                        callback(err);\n                    }\n                    streamArrayParser.emit('error', err);\n                }\n                else if (callback) {\n                    callback(err);\n                }\n                else {\n                    throw err;\n                }\n            });\n            if (rpc.responseStream) {\n                return streamArrayParser;\n            }\n            return {\n                cancel: () => {\n                    cancelRequested = true;\n                    cancelController.abort();\n                },\n            };\n        };\n    }\n    return serviceStub;\n}\nexports.generateServiceStub = generateServiceStub;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}