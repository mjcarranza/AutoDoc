{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\n\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\n\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\n\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\n\nclass DownscopedClient extends authclient_1.AuthClient {\n  /**\n   * Instantiates a downscoped client object using the provided source\n   * AuthClient and credential access boundary rules.\n   * To downscope permissions of a source AuthClient, a Credential Access\n   * Boundary that specifies which resources the new credential can access, as\n   * well as an upper bound on the permissions that are available on each\n   * resource, has to be defined. A downscoped client can then be instantiated\n   * using the source AuthClient and the Credential Access Boundary.\n   * @param authClient The source AuthClient to be downscoped based on the\n   *   provided Credential Access Boundary rules.\n   * @param credentialAccessBoundary The Credential Access Boundary which\n   *   contains a list of access boundary rules. Each rule contains information\n   *   on the resource that the rule applies to, the upper bound of the\n   *   permissions that are available on that resource and an optional\n   *   condition to further restrict permissions.\n   * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**\n   *   Optional additional behavior customization options.\n   * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**\n   *   Optional quota project id for setting up in the x-goog-user-project header.\n   */\n  constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n    super({ ...additionalOptions,\n      quotaProjectId\n    });\n    this.authClient = authClient;\n    this.credentialAccessBoundary = credentialAccessBoundary; // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n\n    if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n    } // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n\n\n    for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {\n      if (rule.availablePermissions.length === 0) {\n        throw new Error('At least one permission should be defined in access boundary rules.');\n      }\n    }\n\n    this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n    this.cachedDownscopedAccessToken = null;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * The expiry_date field is required to facilitate determination of the token\n   * expiration which would make it easier for the token consumer to handle.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  setCredentials(credentials) {\n    if (!credentials.expiry_date) {\n      throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n    }\n\n    super.setCredentials(credentials);\n    this.cachedDownscopedAccessToken = credentials;\n  }\n\n  getAccessToken() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // If the cached access token is unavailable or expired, force refresh.\n      // The Downscoped access token will be returned in\n      // DownscopedAccessTokenResponse format.\n      if (!_this.cachedDownscopedAccessToken || _this.isExpired(_this.cachedDownscopedAccessToken)) {\n        yield _this.refreshAccessTokenAsync();\n      } // Return Downscoped access token in DownscopedAccessTokenResponse format.\n\n\n      return {\n        token: _this.cachedDownscopedAccessToken.access_token,\n        expirationTime: _this.cachedDownscopedAccessToken.expiry_date,\n        res: _this.cachedDownscopedAccessToken.res\n      };\n    })();\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n\n\n  getRequestHeaders() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const accessTokenResponse = yield _this2.getAccessToken();\n      const headers = {\n        Authorization: `Bearer ${accessTokenResponse.token}`\n      };\n      return _this2.addSharedMetadataHeaders(headers);\n    })();\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  requestAsync(opts, retry = false) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let response;\n\n      try {\n        const requestHeaders = yield _this3.getRequestHeaders();\n        opts.headers = opts.headers || {};\n\n        if (requestHeaders && requestHeaders['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n        }\n\n        if (requestHeaders && requestHeaders.Authorization) {\n          opts.headers.Authorization = requestHeaders.Authorization;\n        }\n\n        response = yield _this3.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - forceRefreshOnFailure is true\n\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && _this3.forceRefreshOnFailure) {\n            yield _this3.refreshAccessTokenAsync();\n            return yield _this3.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return response;\n    })();\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * GCP access tokens are retrieved from authclient object/source credential.\n   * Then GCP access tokens are exchanged for downscoped access tokens via the\n   * token exchange endpoint.\n   * @return A promise that resolves with the fresh downscoped access token.\n   */\n\n\n  refreshAccessTokenAsync() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // Retrieve GCP access token from source credential.\n\n\n      const subjectToken = (yield _this4.authClient.getAccessToken()).token; // Construct the STS credentials options.\n\n      const stsCredentialsOptions = {\n        grantType: STS_GRANT_TYPE,\n        requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n        subjectToken: subjectToken,\n        subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n      }; // Exchange the source AuthClient access token for a Downscoped access\n      // token.\n\n      const stsResponse = yield _this4.stsCredential.exchangeToken(stsCredentialsOptions, undefined, _this4.credentialAccessBoundary);\n      /**\n       * The STS endpoint will only return the expiration time for the downscoped\n       * access token if the original access token represents a service account.\n       * The downscoped token's expiration time will always match the source\n       * credential expiration. When no expires_in is returned, we can copy the\n       * source credential's expiration time.\n       */\n\n      const sourceCredExpireDate = ((_a = _this4.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n      const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate; // Save response in cached access token.\n\n      _this4.cachedDownscopedAccessToken = {\n        access_token: stsResponse.access_token,\n        expiry_date: expiryDate,\n        res: stsResponse.res\n      }; // Save credentials.\n\n      _this4.credentials = {};\n      Object.assign(_this4.credentials, _this4.cachedDownscopedAccessToken);\n      delete _this4.credentials.res; // Trigger tokens event to notify external listeners.\n\n      _this4.emit('tokens', {\n        refresh_token: null,\n        expiry_date: _this4.cachedDownscopedAccessToken.expiry_date,\n        access_token: _this4.cachedDownscopedAccessToken.access_token,\n        token_type: 'Bearer',\n        id_token: null\n      }); // Return the cached access token.\n\n\n      return _this4.cachedDownscopedAccessToken;\n    })();\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param downscopedAccessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(downscopedAccessToken) {\n    const now = new Date().getTime();\n    return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.DownscopedClient = DownscopedClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","DownscopedClient","EXPIRATION_TIME_OFFSET","MAX_ACCESS_BOUNDARY_RULES_COUNT","stream","require","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","STS_SUBJECT_TOKEN_TYPE","STS_ACCESS_TOKEN_URL","AuthClient","constructor","authClient","credentialAccessBoundary","additionalOptions","quotaProjectId","accessBoundary","accessBoundaryRules","length","Error","rule","availablePermissions","stsCredential","StsCredentials","cachedDownscopedAccessToken","setCredentials","credentials","expiry_date","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","expirationTime","res","getRequestHeaders","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","retry","requestHeaders","transporter","statusCode","status","isReadableStream","config","data","Readable","isAuthErr","forceRefreshOnFailure","_a","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","subjectTokenType","stsResponse","exchangeToken","undefined","sourceCredExpireDate","expiryDate","expires_in","Date","getTime","assign","emit","refresh_token","token_type","id_token","downscopedAccessToken","now","eagerRefreshThresholdMillis"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-auth-library/build/src/auth/downscopedclient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional additional behavior customization options.\n     * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional quota project id for setting up in the x-goog-user-project header.\n     */\n    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n        super({ ...additionalOptions, quotaProjectId });\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error('The provided access boundary has more than ' +\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary\n            .accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        this.cachedDownscopedAccessToken = null;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error('The access token expiry_date field is missing in the provided ' +\n                'credentials.');\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */\n        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in\n            ? new Date().getTime() + stsResponse.expires_in * 1000\n            : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}