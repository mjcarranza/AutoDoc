{"ast":null,"code":"\"use strict\"; // Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _asyncToGenerator = require(\"C:/Users/mario/Desktop/AutoDocIA/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\n\nconst authclient_1 = require(\"./authclient\");\n\nconst oauth2common_1 = require(\"./oauth2common\");\n\nconst gaxios_1 = require(\"gaxios\");\n\nconst stream = require(\"stream\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */\n\n\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */\n\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n  /**\n   * Initializes an ExternalAccountAuthorizedUserHandler instance.\n   * @param url The URL of the token refresh endpoint.\n   * @param transporter The transporter to use for the refresh request.\n   * @param clientAuthentication The client authentication credentials to use\n   *   for the refresh request.\n   */\n  constructor(url, transporter, clientAuthentication) {\n    super(clientAuthentication);\n    this.url = url;\n    this.transporter = transporter;\n  }\n  /**\n   * Requests a new access token from the token_url endpoint using the provided\n   *   refresh token.\n   * @param refreshToken The refresh token to use to generate a new access token.\n   * @param additionalHeaders Optional additional headers to pass along the\n   *   request.\n   * @return A promise that resolves with the token refresh response containing\n   *   the requested access token and its expiration time.\n   */\n\n\n  refreshToken(refreshToken, additionalHeaders) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const values = new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken\n      });\n      const headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        ...additionalHeaders\n      };\n      const opts = {\n        url: _this.url,\n        method: 'POST',\n        headers,\n        data: values.toString(),\n        responseType: 'json'\n      }; // Apply OAuth client authentication.\n\n      _this.applyClientAuthenticationOptions(opts);\n\n      try {\n        const response = yield _this.transporter.request(opts); // Successful response.\n\n        const tokenRefreshResponse = response.data;\n        tokenRefreshResponse.res = response;\n        return tokenRefreshResponse;\n      } catch (error) {\n        // Translate error to OAuthError.\n        if (error instanceof gaxios_1.GaxiosError && error.response) {\n          throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n          error);\n        } // Request could fail before the server responds.\n\n\n        throw error;\n      }\n    })();\n  }\n\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */\n\n\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n  /**\n   * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n   * provided JSON object loaded from a credentials files.\n   * An error is throws if the credential is not valid.\n   * @param options The external account authorized user option object typically\n   *   from the external accoutn authorized user JSON credential file.\n   * @param additionalOptions **DEPRECATED, all options are available in the\n   *   `options` parameter.** Optional additional behavior customization options.\n   *   These currently customize expiration threshold time and whether to retry\n   *   on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super({ ...options,\n      ...additionalOptions\n    });\n    this.refreshToken = options.refresh_token;\n    const clientAuth = {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    };\n    this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n    this.cachedAccessToken = null;\n    this.quotaProjectId = options.quota_project_id; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n\n    if (options.universe_domain) {\n      this.universeDomain = options.universe_domain;\n    }\n  }\n\n  getAccessToken() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // If cached access token is unavailable or expired, force refresh.\n      if (!_this2.cachedAccessToken || _this2.isExpired(_this2.cachedAccessToken)) {\n        yield _this2.refreshAccessTokenAsync();\n      } // Return GCP access token in GetAccessTokenResponse format.\n\n\n      return {\n        token: _this2.cachedAccessToken.access_token,\n        res: _this2.cachedAccessToken.res\n      };\n    })();\n  }\n\n  getRequestHeaders() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const accessTokenResponse = yield _this3.getAccessToken();\n      const headers = {\n        Authorization: `Bearer ${accessTokenResponse.token}`\n      };\n      return _this3.addSharedMetadataHeaders(headers);\n    })();\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  requestAsync(opts, retry = false) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let response;\n\n      try {\n        const requestHeaders = yield _this4.getRequestHeaders();\n        opts.headers = opts.headers || {};\n\n        if (requestHeaders && requestHeaders['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n        }\n\n        if (requestHeaders && requestHeaders.Authorization) {\n          opts.headers.Authorization = requestHeaders.Authorization;\n        }\n\n        response = yield _this4.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - forceRefreshOnFailure is true\n\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && _this4.forceRefreshOnFailure) {\n            yield _this4.refreshAccessTokenAsync();\n            return yield _this4.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return response;\n    })();\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * @return A promise that resolves with the refreshed credential.\n   */\n\n\n  refreshAccessTokenAsync() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // Refresh the access token using the refresh token.\n      const refreshResponse = yield _this5.externalAccountAuthorizedUserHandler.refreshToken(_this5.refreshToken);\n      _this5.cachedAccessToken = {\n        access_token: refreshResponse.access_token,\n        expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n        res: refreshResponse.res\n      };\n\n      if (refreshResponse.refresh_token !== undefined) {\n        _this5.refreshToken = refreshResponse.refresh_token;\n      }\n\n      return _this5.cachedAccessToken;\n    })();\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param credentials The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(credentials) {\n    const now = new Date().getTime();\n    return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","ExternalAccountAuthorizedUserClient","EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE","authclient_1","require","oauth2common_1","gaxios_1","stream","baseexternalclient_1","ExternalAccountAuthorizedUserHandler","OAuthClientAuthHandler","constructor","url","transporter","clientAuthentication","refreshToken","additionalHeaders","values","URLSearchParams","grant_type","refresh_token","headers","opts","method","data","toString","responseType","applyClientAuthenticationOptions","response","request","tokenRefreshResponse","res","error","GaxiosError","getErrorFromOAuthErrorResponse","AuthClient","options","additionalOptions","clientAuth","confidentialClientType","clientId","client_id","clientSecret","client_secret","externalAccountAuthorizedUserHandler","token_url","cachedAccessToken","quotaProjectId","quota_project_id","eagerRefreshThresholdMillis","EXPIRATION_TIME_OFFSET","forceRefreshOnFailure","universe_domain","universeDomain","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","getRequestHeaders","accessTokenResponse","Authorization","addSharedMetadataHeaders","callback","requestAsync","then","r","e","retry","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","refreshResponse","expiry_date","Date","getTime","expires_in","undefined","credentials","now"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"],"sourcesContent":["\"use strict\";\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = require(\"./authclient\");\nconst oauth2common_1 = require(\"./oauth2common\");\nconst gaxios_1 = require(\"gaxios\");\nconst stream = require(\"stream\");\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */\n    constructor(url, transporter, clientAuthentication) {\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */\n    async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n        });\n        const headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            ...additionalHeaders,\n        };\n        const opts = {\n            url: this.url,\n            method: 'POST',\n            headers,\n            data: values.toString(),\n            responseType: 'json',\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        }\n        catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \n                // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super({ ...options, ...additionalOptions });\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: 'basic',\n            clientId: options.client_id,\n            clientSecret: options.client_secret,\n        };\n        this.externalAccountAuthorizedUserHandler =\n            new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        if (options.universe_domain) {\n            this.universeDomain = options.universe_domain;\n        }\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */\n    async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res,\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date\n            ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}