{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst warnings_1 = require(\"../warnings\");\n\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\n\nconst task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\n\n\nclass BundleExecutor {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  constructor(bundleOptions, bundleDescriptor) {\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  schedule(apiCall, request, callback) {\n    const bundleId = (0, bundlingUtils_1.computeBundleId)(request, this._descriptor.requestDiscriminatorFields);\n    callback = callback || noop;\n\n    if (bundleId === undefined) {\n      (0, warnings_1.warn)('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + `Invoking immediately. Request: ${JSON.stringify(request)} ` + `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n      return apiCall(request, callback);\n    }\n\n    if (request[this._descriptor.bundledField] === undefined) {\n      (0, warnings_1.warn)('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` + `Invoking immediately. Request: ${JSON.stringify(request)}`);\n      return apiCall(request, callback);\n    }\n\n    if (!(bundleId in this._tasks)) {\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n    }\n\n    let task = this._tasks[bundleId];\n    callback.id = String(this._invocationId++);\n    this._invocations[callback.id] = bundleId;\n    const bundledField = request[this._descriptor.bundledField];\n    const elementCount = bundledField.length;\n    let requestBytes = 0; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const self = this;\n    bundledField.forEach(obj => {\n      requestBytes += this._descriptor.byteLengthFunction(obj);\n    });\n    const countLimit = this._options.elementCountLimit || 0;\n    const byteLimit = this._options.requestByteLimit || 0;\n\n    if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n      let message;\n\n      if (countLimit > 0 && elementCount > countLimit) {\n        message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n      } else {\n        message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n      }\n\n      const error = new googleError_1.GoogleError(message);\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n      return {\n        cancel: noop\n      };\n    }\n\n    const existingCount = task.getElementCount();\n    const existingBytes = task.getRequestByteSize();\n\n    if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n      this._runNow(bundleId);\n\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      task = this._tasks[bundleId];\n    }\n\n    task.extend(bundledField, requestBytes, callback);\n    const ret = {\n      cancel() {\n        self._cancel(callback.id);\n      }\n\n    };\n    const countThreshold = this._options.elementCountThreshold || 0;\n    const sizeThreshold = this._options.requestByteThreshold || 0;\n\n    if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n      this._runNow(bundleId);\n\n      return ret;\n    }\n\n    if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n      this._timers[bundleId] = setTimeout(() => {\n        delete this._timers[bundleId];\n\n        this._runNow(bundleId);\n      }, this._options.delayThreshold);\n    }\n\n    return ret;\n  }\n  /**\n   * Clears scheduled timeout if it exists.\n   *\n   * @param {String} bundleId - the id for the task whose timeout needs to be\n   *   cleared.\n   * @private\n   */\n\n\n  _maybeClearTimeout(bundleId) {\n    if (bundleId in this._timers) {\n      const timerId = this._timers[bundleId];\n      delete this._timers[bundleId];\n      clearTimeout(timerId);\n    }\n  }\n  /**\n   * Cancels an event.\n   *\n   * @param {String} id - The id for the event in the task.\n   * @private\n   */\n\n\n  _cancel(id) {\n    if (!(id in this._invocations)) {\n      return;\n    }\n\n    const bundleId = this._invocations[id];\n\n    if (!(bundleId in this._tasks)) {\n      return;\n    }\n\n    const task = this._tasks[bundleId];\n    delete this._invocations[id];\n\n    if (task.cancel(id)) {\n      this._maybeClearTimeout(bundleId);\n\n      delete this._tasks[bundleId];\n    }\n  }\n  /**\n   * Invokes a task.\n   *\n   * @param {String} bundleId - The id for the task.\n   * @private\n   */\n\n\n  _runNow(bundleId) {\n    if (!(bundleId in this._tasks)) {\n      (0, warnings_1.warn)('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n      return;\n    }\n\n    this._maybeClearTimeout(bundleId);\n\n    const task = this._tasks[bundleId];\n    delete this._tasks[bundleId];\n    task.run().forEach(id => {\n      delete this._invocations[id];\n    });\n  }\n\n}\n\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"names":["Object","defineProperty","exports","value","BundleExecutor","status_1","require","googleError_1","warnings_1","bundlingUtils_1","task_1","noop","constructor","bundleOptions","bundleDescriptor","_options","_descriptor","_tasks","_timers","_invocations","_invocationId","schedule","apiCall","request","callback","bundleId","computeBundleId","requestDiscriminatorFields","undefined","warn","JSON","stringify","bundledField","Task","subresponseField","task","id","String","elementCount","length","requestBytes","self","forEach","obj","byteLengthFunction","countLimit","elementCountLimit","byteLimit","requestByteLimit","message","error","GoogleError","code","Status","INVALID_ARGUMENT","cancel","existingCount","getElementCount","existingBytes","getRequestByteSize","_runNow","extend","ret","_cancel","countThreshold","elementCountThreshold","sizeThreshold","requestByteThreshold","delayThreshold","setTimeout","_maybeClearTimeout","timerId","clearTimeout","run"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/bundlingCalls/bundleExecutor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleExecutor = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst warnings_1 = require(\"../warnings\");\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\nconst task_1 = require(\"./task\");\nfunction noop() { }\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\nclass BundleExecutor {\n    /**\n     * Organizes requests for an api service that requires to bundle them.\n     *\n     * @param {BundleOptions} bundleOptions - configures strategy this instance\n     *   uses when executing bundled functions.\n     * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n     * @constructor\n     */\n    constructor(bundleOptions, bundleDescriptor) {\n        this._options = bundleOptions;\n        this._descriptor = bundleDescriptor;\n        this._tasks = {};\n        this._timers = {};\n        this._invocations = {};\n        this._invocationId = 0;\n    }\n    /**\n     * Schedule a method call.\n     *\n     * @param {function} apiCall - the function for an API call.\n     * @param {Object} request - the request object to be bundled with others.\n     * @param {APICallback} callback - the callback to be called when the method finished.\n     * @return {function()} - the function to cancel the scheduled invocation.\n     */\n    schedule(apiCall, request, callback) {\n        const bundleId = (0, bundlingUtils_1.computeBundleId)(request, this._descriptor.requestDiscriminatorFields);\n        callback = (callback || noop);\n        if (bundleId === undefined) {\n            (0, warnings_1.warn)('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' +\n                `Invoking immediately. Request: ${JSON.stringify(request)} ` +\n                `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n            return apiCall(request, callback);\n        }\n        if (request[this._descriptor.bundledField] === undefined) {\n            (0, warnings_1.warn)('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` +\n                `Invoking immediately. Request: ${JSON.stringify(request)}`);\n            return apiCall(request, callback);\n        }\n        if (!(bundleId in this._tasks)) {\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        }\n        let task = this._tasks[bundleId];\n        callback.id = String(this._invocationId++);\n        this._invocations[callback.id] = bundleId;\n        const bundledField = request[this._descriptor.bundledField];\n        const elementCount = bundledField.length;\n        let requestBytes = 0;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        bundledField.forEach(obj => {\n            requestBytes += this._descriptor.byteLengthFunction(obj);\n        });\n        const countLimit = this._options.elementCountLimit || 0;\n        const byteLimit = this._options.requestByteLimit || 0;\n        if ((countLimit > 0 && elementCount > countLimit) ||\n            (byteLimit > 0 && requestBytes >= byteLimit)) {\n            let message;\n            if (countLimit > 0 && elementCount > countLimit) {\n                message =\n                    'The number of elements ' +\n                        elementCount +\n                        ' exceeds the limit ' +\n                        this._options.elementCountLimit;\n            }\n            else {\n                message =\n                    'The required bytes ' +\n                        requestBytes +\n                        ' exceeds the limit ' +\n                        this._options.requestByteLimit;\n            }\n            const error = new googleError_1.GoogleError(message);\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n            return {\n                cancel: noop,\n            };\n        }\n        const existingCount = task.getElementCount();\n        const existingBytes = task.getRequestByteSize();\n        if ((countLimit > 0 && elementCount + existingCount >= countLimit) ||\n            (byteLimit > 0 && requestBytes + existingBytes >= byteLimit)) {\n            this._runNow(bundleId);\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n            task = this._tasks[bundleId];\n        }\n        task.extend(bundledField, requestBytes, callback);\n        const ret = {\n            cancel() {\n                self._cancel(callback.id);\n            },\n        };\n        const countThreshold = this._options.elementCountThreshold || 0;\n        const sizeThreshold = this._options.requestByteThreshold || 0;\n        if ((countThreshold > 0 && task.getElementCount() >= countThreshold) ||\n            (sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold)) {\n            this._runNow(bundleId);\n            return ret;\n        }\n        if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n            this._timers[bundleId] = setTimeout(() => {\n                delete this._timers[bundleId];\n                this._runNow(bundleId);\n            }, this._options.delayThreshold);\n        }\n        return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n    _maybeClearTimeout(bundleId) {\n        if (bundleId in this._timers) {\n            const timerId = this._timers[bundleId];\n            delete this._timers[bundleId];\n            clearTimeout(timerId);\n        }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n    _cancel(id) {\n        if (!(id in this._invocations)) {\n            return;\n        }\n        const bundleId = this._invocations[id];\n        if (!(bundleId in this._tasks)) {\n            return;\n        }\n        const task = this._tasks[bundleId];\n        delete this._invocations[id];\n        if (task.cancel(id)) {\n            this._maybeClearTimeout(bundleId);\n            delete this._tasks[bundleId];\n        }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n    _runNow(bundleId) {\n        if (!(bundleId in this._tasks)) {\n            (0, warnings_1.warn)('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n            return;\n        }\n        this._maybeClearTimeout(bundleId);\n        const task = this._tasks[bundleId];\n        delete this._tasks[bundleId];\n        task.run().forEach(id => {\n            delete this._invocations[id];\n        });\n    }\n}\nexports.BundleExecutor = BundleExecutor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}