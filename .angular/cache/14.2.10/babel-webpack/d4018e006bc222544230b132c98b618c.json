{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\n\nclass PathTemplate {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  match(path) {\n    let pathSegments = path.split('/');\n    const bindings = {};\n\n    if (pathSegments.length !== this.segments.length) {\n      // if the path contains a wildcard, then the length may differ by 1.\n      if (!this.data.includes('**')) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n      } else if (pathSegments.length !== this.segments.length + 1) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n      }\n    }\n\n    for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n      if (this.segments[index] !== pathSegments[0]) {\n        if (!this.segments[index].includes('*')) {\n          throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n        } else {\n          let segment = this.segments[index];\n          const matches = segment.match(/\\{[$0-9a-zA-Z_]+=.*?\\}/g);\n\n          if (!matches) {\n            throw new Error(`Error processing path template segment ${segment}`);\n          }\n\n          const variables = matches.map(str => str.replace(/^\\{/, '').replace(/=.*/, ''));\n\n          if (segment.includes('**')) {\n            bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\n            pathSegments = pathSegments.slice(2);\n          } else {\n            // atomic resource\n            if (variables.length === 1) {\n              bindings[variables[0]] = pathSegments[0];\n            } else {\n              // non-slash resource\n              // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n              // split the match pathSegments[0] -> value: ['bar', 'user2']\n              // compare the length of two arrays, and compare array items\n              const value = pathSegments[0].split(/[-_.~]/);\n\n              if (value.length !== variables.length) {\n                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n              }\n\n              for (const v of variables) {\n                bindings[v] = value[0];\n                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                value.shift();\n              } // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n\n\n              if (segment !== pathSegments[0]) {\n                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n              }\n            }\n\n            pathSegments.shift();\n          }\n        }\n      } else {\n        pathSegments.shift();\n      }\n    }\n\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n\n\n  render(bindings) {\n    if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n      throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n    }\n\n    let path = this.inspect();\n\n    for (const key of Object.keys(bindings)) {\n      const b = bindings[key].toString();\n\n      if (!this.bindings[key]) {\n        throw new TypeError(`render fails for not matching ${bindings[key]}`);\n      }\n\n      const variable = this.bindings[key];\n\n      if (variable === '*') {\n        if (!b.match(/[^/{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=*}`, `${b}`);\n      } else if (variable === '**') {\n        if (!b.match(/[^{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=**}`, `${b}`);\n      }\n    }\n\n    return path;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n\n\n  inspect() {\n    return this.segments.join('/');\n  }\n  /**\n   * Parse the path template.\n   *\n   * @return {string[]} return segments of the input path.\n   * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n   */\n\n\n  parsePathTemplate(data) {\n    const pathSegments = splitPathTemplate(data);\n    let index = 0;\n    let wildCardCount = 0;\n    const segments = [];\n    let matches;\n    pathSegments.forEach(segment => {\n      // * or ** -> segments.push('{$0=*}');\n      //         -> bindings['$0'] = '*'\n      if (segment === '*' || segment === '**') {\n        this.bindings[`$${index}`] = segment;\n        segments.push(`{$${index}=${segment}}`);\n        index = index + 1;\n\n        if (segment === '**') {\n          ++wildCardCount;\n        }\n      } else if (matches = segment.match(/\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\}/g)) {\n        for (const subsegment of matches) {\n          const pairMatch = subsegment.match(/^\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\}$/);\n\n          if (!pairMatch) {\n            throw new Error(`Cannot process path template segment ${subsegment}`);\n          }\n\n          const key = pairMatch[1];\n          let value = pairMatch[2];\n\n          if (!value) {\n            value = '*';\n            segment = segment.replace(key, key + '=*');\n            this.bindings[key] = value;\n          } else if (value === '*') {\n            this.bindings[key] = value;\n          } else if (value === '**') {\n            ++wildCardCount;\n            this.bindings[key] = value;\n          }\n        }\n\n        segments.push(segment);\n      } else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n        segments.push(segment);\n      }\n    });\n\n    if (wildCardCount > 1) {\n      throw new TypeError('Can not have more than one wildcard.');\n    }\n\n    return segments;\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\n\nfunction splitPathTemplate(data) {\n  let left = 0;\n  let right = 0;\n  let bracketCount = 0;\n  const segments = [];\n\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n\n      segments.push(data.substring(left));\n    }\n\n    right = right + 1;\n  }\n\n  return segments;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","PathTemplate","constructor","data","bindings","segments","parsePathTemplate","size","length","match","path","pathSegments","split","includes","TypeError","index","segment","matches","Error","variables","map","str","replace","slice","v","shift","render","keys","inspect","key","b","toString","variable","join","splitPathTemplate","wildCardCount","forEach","push","subsegment","pairMatch","left","right","bracketCount","charAt","substring"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/google-gax/build/src/pathTemplate.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathTemplate = void 0;\nclass PathTemplate {\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n    constructor(data) {\n        this.bindings = {};\n        this.data = data;\n        this.segments = this.parsePathTemplate(data);\n        this.size = this.segments.length;\n    }\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    match(path) {\n        let pathSegments = path.split('/');\n        const bindings = {};\n        if (pathSegments.length !== this.segments.length) {\n            // if the path contains a wildcard, then the length may differ by 1.\n            if (!this.data.includes('**')) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n            }\n            else if (pathSegments.length !== this.segments.length + 1) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n            }\n        }\n        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n            if (this.segments[index] !== pathSegments[0]) {\n                if (!this.segments[index].includes('*')) {\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n                }\n                else {\n                    let segment = this.segments[index];\n                    const matches = segment.match(/\\{[$0-9a-zA-Z_]+=.*?\\}/g);\n                    if (!matches) {\n                        throw new Error(`Error processing path template segment ${segment}`);\n                    }\n                    const variables = matches.map(str => str.replace(/^\\{/, '').replace(/=.*/, ''));\n                    if (segment.includes('**')) {\n                        bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\n                        pathSegments = pathSegments.slice(2);\n                    }\n                    else {\n                        // atomic resource\n                        if (variables.length === 1) {\n                            bindings[variables[0]] = pathSegments[0];\n                        }\n                        else {\n                            // non-slash resource\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n                            // split the match pathSegments[0] -> value: ['bar', 'user2']\n                            // compare the length of two arrays, and compare array items\n                            const value = pathSegments[0].split(/[-_.~]/);\n                            if (value.length !== variables.length) {\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n                            }\n                            for (const v of variables) {\n                                bindings[v] = value[0];\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                                value.shift();\n                            }\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n                            if (segment !== pathSegments[0]) {\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n                            }\n                        }\n                        pathSegments.shift();\n                    }\n                }\n            }\n            else {\n                pathSegments.shift();\n            }\n        }\n        return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n    render(bindings) {\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n        }\n        let path = this.inspect();\n        for (const key of Object.keys(bindings)) {\n            const b = bindings[key].toString();\n            if (!this.bindings[key]) {\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\n            }\n            const variable = this.bindings[key];\n            if (variable === '*') {\n                if (!b.match(/[^/{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=*}`, `${b}`);\n            }\n            else if (variable === '**') {\n                if (!b.match(/[^{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=**}`, `${b}`);\n            }\n        }\n        return path;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n    inspect() {\n        return this.segments.join('/');\n    }\n    /**\n     * Parse the path template.\n     *\n     * @return {string[]} return segments of the input path.\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n     */\n    parsePathTemplate(data) {\n        const pathSegments = splitPathTemplate(data);\n        let index = 0;\n        let wildCardCount = 0;\n        const segments = [];\n        let matches;\n        pathSegments.forEach(segment => {\n            // * or ** -> segments.push('{$0=*}');\n            //         -> bindings['$0'] = '*'\n            if (segment === '*' || segment === '**') {\n                this.bindings[`$${index}`] = segment;\n                segments.push(`{$${index}=${segment}}`);\n                index = index + 1;\n                if (segment === '**') {\n                    ++wildCardCount;\n                }\n            }\n            else if ((matches = segment.match(/\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\}/g))) {\n                for (const subsegment of matches) {\n                    const pairMatch = subsegment.match(/^\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\}$/);\n                    if (!pairMatch) {\n                        throw new Error(`Cannot process path template segment ${subsegment}`);\n                    }\n                    const key = pairMatch[1];\n                    let value = pairMatch[2];\n                    if (!value) {\n                        value = '*';\n                        segment = segment.replace(key, key + '=*');\n                        this.bindings[key] = value;\n                    }\n                    else if (value === '*') {\n                        this.bindings[key] = value;\n                    }\n                    else if (value === '**') {\n                        ++wildCardCount;\n                        this.bindings[key] = value;\n                    }\n                }\n                segments.push(segment);\n            }\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                segments.push(segment);\n            }\n        });\n        if (wildCardCount > 1) {\n            throw new TypeError('Can not have more than one wildcard.');\n        }\n        return segments;\n    }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\nfunction splitPathTemplate(data) {\n    let left = 0;\n    let right = 0;\n    let bracketCount = 0;\n    const segments = [];\n    while (right >= left && right < data.length) {\n        if (data.charAt(right) === '{') {\n            bracketCount = bracketCount + 1;\n        }\n        else if (data.charAt(right) === '}') {\n            bracketCount = bracketCount - 1;\n        }\n        else if (data.charAt(right) === '/') {\n            if (right === data.length - 1) {\n                throw new TypeError('Invalid path, it can not be ended by /');\n            }\n            if (bracketCount === 0) {\n                // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n                segments.push(data.substring(left, right));\n                left = right + 1;\n            }\n        }\n        if (right === data.length - 1) {\n            if (bracketCount !== 0) {\n                throw new TypeError('Brackets are invalid.');\n            }\n            segments.push(data.substring(left));\n        }\n        right = right + 1;\n    }\n    return segments;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}