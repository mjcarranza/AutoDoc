{"ast":null,"code":"'use strict';\n\nconst {\n  PassThrough\n} = require('stream');\n\nconst debug = require('debug')('retry-request');\n\nconst extend = require('extend');\n\nconst DEFAULTS = {\n  objectMode: false,\n  retries: 2,\n\n  /*\n    The maximum time to delay in seconds. If retryDelayMultiplier results in a\n    delay greater than maxRetryDelay, retries should delay by maxRetryDelay\n    seconds instead.\n  */\n  maxRetryDelay: 64,\n\n  /*\n    The multiplier by which to increase the delay time between the completion of\n    failed requests, and the initiation of the subsequent retrying request.\n  */\n  retryDelayMultiplier: 2,\n\n  /*\n    The length of time to keep retrying in seconds. The last sleep period will\n    be shortened as necessary, so that the last retry runs at deadline (and not\n    considerably beyond it).  The total time starting from when the initial\n    request is sent, after which an error will be returned, regardless of the\n    retrying attempts made meanwhile.\n   */\n  totalTimeout: 600,\n  noResponseRetries: 2,\n  currentRetryAttempt: 0,\n  shouldRetryFn: function (response) {\n    const retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n    // 1xx - Retry (Informational, request still processing)\n    // 2xx - Do not retry (Success)\n    // 3xx - Do not retry (Redirect)\n    // 4xx - Do not retry (Client errors)\n    // 429 - Retry (\"Too Many Requests\")\n    // 5xx - Retry (Server errors)\n    [100, 199], [429, 429], [500, 599]];\n    const statusCode = response.statusCode;\n    debug(`Response status: ${statusCode}`);\n    let range;\n\n    while (range = retryRanges.shift()) {\n      if (statusCode >= range[0] && statusCode <= range[1]) {\n        // Not a successful status or redirect.\n        return true;\n      }\n    }\n  }\n};\n\nfunction retryRequest(requestOpts, opts, callback) {\n  if (typeof requestOpts === 'string') {\n    requestOpts = {\n      url: requestOpts\n    };\n  }\n\n  const streamMode = typeof arguments[arguments.length - 1] !== 'function';\n\n  if (typeof opts === 'function') {\n    callback = opts;\n  }\n\n  const manualCurrentRetryAttemptWasSet = opts && typeof opts.currentRetryAttempt === 'number';\n  opts = extend({}, DEFAULTS, opts);\n\n  if (typeof opts.request === 'undefined') {\n    throw new Error('A request library must be provided to retry-request.');\n  }\n\n  let currentRetryAttempt = opts.currentRetryAttempt;\n  let numNoResponseAttempts = 0;\n  let streamResponseHandled = false;\n  let retryStream;\n  let requestStream;\n  let delayStream;\n  let activeRequest;\n  const retryRequest = {\n    abort: function () {\n      if (activeRequest && activeRequest.abort) {\n        activeRequest.abort();\n      }\n    }\n  };\n\n  if (streamMode) {\n    retryStream = new PassThrough({\n      objectMode: opts.objectMode\n    });\n    retryStream.abort = resetStreams;\n  }\n\n  const timeOfFirstRequest = Date.now();\n\n  if (currentRetryAttempt > 0) {\n    retryAfterDelay(currentRetryAttempt);\n  } else {\n    makeRequest();\n  }\n\n  if (streamMode) {\n    return retryStream;\n  } else {\n    return retryRequest;\n  }\n\n  function resetStreams() {\n    delayStream = null;\n\n    if (requestStream) {\n      requestStream.abort && requestStream.abort();\n      requestStream.cancel && requestStream.cancel();\n\n      if (requestStream.destroy) {\n        requestStream.destroy();\n      } else if (requestStream.end) {\n        requestStream.end();\n      }\n    }\n  }\n\n  function makeRequest() {\n    let finishHandled = false;\n    currentRetryAttempt++;\n    debug(`Current retry attempt: ${currentRetryAttempt}`);\n\n    function handleFinish(args = []) {\n      if (!finishHandled) {\n        finishHandled = true;\n        retryStream.emit('complete', ...args);\n      }\n    }\n\n    if (streamMode) {\n      streamResponseHandled = false;\n      delayStream = new PassThrough({\n        objectMode: opts.objectMode\n      });\n      requestStream = opts.request(requestOpts);\n      setImmediate(() => {\n        retryStream.emit('request');\n      });\n      requestStream // gRPC via google-cloud-node can emit an `error` as well as a `response`\n      // Whichever it emits, we run with-- we can't run with both. That's what\n      // is up with the `streamResponseHandled` tracking.\n      .on('error', err => {\n        if (streamResponseHandled) {\n          return;\n        }\n\n        streamResponseHandled = true;\n        onResponse(err);\n      }).on('response', (resp, body) => {\n        if (streamResponseHandled) {\n          return;\n        }\n\n        streamResponseHandled = true;\n        onResponse(null, resp, body);\n      }).on('complete', (...params) => handleFinish(params)).on('finish', (...params) => handleFinish(params));\n      requestStream.pipe(delayStream);\n    } else {\n      activeRequest = opts.request(requestOpts, onResponse);\n    }\n  }\n\n  function retryAfterDelay(currentRetryAttempt) {\n    if (streamMode) {\n      resetStreams();\n    }\n\n    const nextRetryDelay = getNextRetryDelay({\n      maxRetryDelay: opts.maxRetryDelay,\n      retryDelayMultiplier: opts.retryDelayMultiplier,\n      retryNumber: currentRetryAttempt,\n      timeOfFirstRequest,\n      totalTimeout: opts.totalTimeout\n    });\n    debug(`Next retry delay: ${nextRetryDelay}`);\n\n    if (nextRetryDelay <= 0) {\n      numNoResponseAttempts = opts.noResponseRetries + 1;\n      return;\n    }\n\n    setTimeout(makeRequest, nextRetryDelay);\n  }\n\n  function onResponse(err, response, body) {\n    // An error such as DNS resolution.\n    if (err) {\n      numNoResponseAttempts++;\n\n      if (numNoResponseAttempts <= opts.noResponseRetries) {\n        retryAfterDelay(numNoResponseAttempts);\n      } else {\n        if (streamMode) {\n          retryStream.emit('error', err);\n          retryStream.end();\n        } else {\n          callback(err, response, body);\n        }\n      }\n\n      return;\n    } // Send the response to see if we should try again.\n    // NOTE: \"currentRetryAttempt\" isn't accurate by default, as it counts\n    // the very first request sent as the first \"retry\". It is only accurate\n    // when a user provides their own \"currentRetryAttempt\" option at\n    // instantiation.\n\n\n    const adjustedCurrentRetryAttempt = manualCurrentRetryAttemptWasSet ? currentRetryAttempt : currentRetryAttempt - 1;\n\n    if (adjustedCurrentRetryAttempt < opts.retries && opts.shouldRetryFn(response)) {\n      retryAfterDelay(currentRetryAttempt);\n      return;\n    } // No more attempts need to be made, just continue on.\n\n\n    if (streamMode) {\n      retryStream.emit('response', response);\n      delayStream.pipe(retryStream);\n      requestStream.on('error', err => {\n        retryStream.destroy(err);\n      });\n    } else {\n      callback(err, response, body);\n    }\n  }\n}\n\nmodule.exports = retryRequest;\n\nfunction getNextRetryDelay(config) {\n  const {\n    maxRetryDelay,\n    retryDelayMultiplier,\n    retryNumber,\n    timeOfFirstRequest,\n    totalTimeout\n  } = config;\n  const maxRetryDelayMs = maxRetryDelay * 1000;\n  const totalTimeoutMs = totalTimeout * 1000;\n  const jitter = Math.floor(Math.random() * 1000);\n  const calculatedNextRetryDelay = Math.pow(retryDelayMultiplier, retryNumber) * 1000 + jitter;\n  const maxAllowableDelayMs = totalTimeoutMs - (Date.now() - timeOfFirstRequest);\n  return Math.min(calculatedNextRetryDelay, maxAllowableDelayMs, maxRetryDelayMs);\n}\n\nmodule.exports.defaults = DEFAULTS;\nmodule.exports.getNextRetryDelay = getNextRetryDelay;","map":{"version":3,"names":["PassThrough","require","debug","extend","DEFAULTS","objectMode","retries","maxRetryDelay","retryDelayMultiplier","totalTimeout","noResponseRetries","currentRetryAttempt","shouldRetryFn","response","retryRanges","statusCode","range","shift","retryRequest","requestOpts","opts","callback","url","streamMode","arguments","length","manualCurrentRetryAttemptWasSet","request","Error","numNoResponseAttempts","streamResponseHandled","retryStream","requestStream","delayStream","activeRequest","abort","resetStreams","timeOfFirstRequest","Date","now","retryAfterDelay","makeRequest","cancel","destroy","end","finishHandled","handleFinish","args","emit","setImmediate","on","err","onResponse","resp","body","params","pipe","nextRetryDelay","getNextRetryDelay","retryNumber","setTimeout","adjustedCurrentRetryAttempt","module","exports","config","maxRetryDelayMs","totalTimeoutMs","jitter","Math","floor","random","calculatedNextRetryDelay","pow","maxAllowableDelayMs","min","defaults"],"sources":["C:/Users/mario/Desktop/AutoDocIA/node_modules/retry-request/index.js"],"sourcesContent":["'use strict';\n\nconst {PassThrough} = require('stream');\nconst debug = require('debug')('retry-request');\nconst extend = require('extend');\n\nconst DEFAULTS = {\n  objectMode: false,\n  retries: 2,\n\n  /*\n    The maximum time to delay in seconds. If retryDelayMultiplier results in a\n    delay greater than maxRetryDelay, retries should delay by maxRetryDelay\n    seconds instead.\n  */\n  maxRetryDelay: 64,\n\n  /*\n    The multiplier by which to increase the delay time between the completion of\n    failed requests, and the initiation of the subsequent retrying request.\n  */\n  retryDelayMultiplier: 2,\n\n  /*\n    The length of time to keep retrying in seconds. The last sleep period will\n    be shortened as necessary, so that the last retry runs at deadline (and not\n    considerably beyond it).  The total time starting from when the initial\n    request is sent, after which an error will be returned, regardless of the\n    retrying attempts made meanwhile.\n   */\n  totalTimeout: 600,\n\n  noResponseRetries: 2,\n  currentRetryAttempt: 0,\n  shouldRetryFn: function (response) {\n    const retryRanges = [\n      // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n      // 1xx - Retry (Informational, request still processing)\n      // 2xx - Do not retry (Success)\n      // 3xx - Do not retry (Redirect)\n      // 4xx - Do not retry (Client errors)\n      // 429 - Retry (\"Too Many Requests\")\n      // 5xx - Retry (Server errors)\n      [100, 199],\n      [429, 429],\n      [500, 599],\n    ];\n\n    const statusCode = response.statusCode;\n    debug(`Response status: ${statusCode}`);\n\n    let range;\n    while ((range = retryRanges.shift())) {\n      if (statusCode >= range[0] && statusCode <= range[1]) {\n        // Not a successful status or redirect.\n        return true;\n      }\n    }\n  },\n};\n\nfunction retryRequest(requestOpts, opts, callback) {\n  if (typeof requestOpts === 'string') {\n    requestOpts = {url: requestOpts};\n  }\n\n  const streamMode = typeof arguments[arguments.length - 1] !== 'function';\n\n  if (typeof opts === 'function') {\n    callback = opts;\n  }\n\n  const manualCurrentRetryAttemptWasSet =\n    opts && typeof opts.currentRetryAttempt === 'number';\n  opts = extend({}, DEFAULTS, opts);\n\n  if (typeof opts.request === 'undefined') {\n    throw new Error('A request library must be provided to retry-request.');\n  }\n\n  let currentRetryAttempt = opts.currentRetryAttempt;\n\n  let numNoResponseAttempts = 0;\n  let streamResponseHandled = false;\n\n  let retryStream;\n  let requestStream;\n  let delayStream;\n\n  let activeRequest;\n  const retryRequest = {\n    abort: function () {\n      if (activeRequest && activeRequest.abort) {\n        activeRequest.abort();\n      }\n    },\n  };\n\n  if (streamMode) {\n    retryStream = new PassThrough({objectMode: opts.objectMode});\n    retryStream.abort = resetStreams;\n  }\n\n  const timeOfFirstRequest = Date.now();\n  if (currentRetryAttempt > 0) {\n    retryAfterDelay(currentRetryAttempt);\n  } else {\n    makeRequest();\n  }\n\n  if (streamMode) {\n    return retryStream;\n  } else {\n    return retryRequest;\n  }\n\n  function resetStreams() {\n    delayStream = null;\n\n    if (requestStream) {\n      requestStream.abort && requestStream.abort();\n      requestStream.cancel && requestStream.cancel();\n\n      if (requestStream.destroy) {\n        requestStream.destroy();\n      } else if (requestStream.end) {\n        requestStream.end();\n      }\n    }\n  }\n\n  function makeRequest() {\n    let finishHandled = false;\n    currentRetryAttempt++;\n    debug(`Current retry attempt: ${currentRetryAttempt}`);\n\n    function handleFinish(args = []) {\n      if (!finishHandled) {\n        finishHandled = true;\n        retryStream.emit('complete', ...args);\n      }\n    }\n\n    if (streamMode) {\n      streamResponseHandled = false;\n\n      delayStream = new PassThrough({objectMode: opts.objectMode});\n      requestStream = opts.request(requestOpts);\n\n      setImmediate(() => {\n        retryStream.emit('request');\n      });\n\n      requestStream\n        // gRPC via google-cloud-node can emit an `error` as well as a `response`\n        // Whichever it emits, we run with-- we can't run with both. That's what\n        // is up with the `streamResponseHandled` tracking.\n        .on('error', err => {\n          if (streamResponseHandled) {\n            return;\n          }\n\n          streamResponseHandled = true;\n          onResponse(err);\n        })\n        .on('response', (resp, body) => {\n          if (streamResponseHandled) {\n            return;\n          }\n\n          streamResponseHandled = true;\n          onResponse(null, resp, body);\n        })\n        .on('complete', (...params) => handleFinish(params))\n        .on('finish', (...params) => handleFinish(params));\n\n      requestStream.pipe(delayStream);\n    } else {\n      activeRequest = opts.request(requestOpts, onResponse);\n    }\n  }\n\n  function retryAfterDelay(currentRetryAttempt) {\n    if (streamMode) {\n      resetStreams();\n    }\n\n    const nextRetryDelay = getNextRetryDelay({\n      maxRetryDelay: opts.maxRetryDelay,\n      retryDelayMultiplier: opts.retryDelayMultiplier,\n      retryNumber: currentRetryAttempt,\n      timeOfFirstRequest,\n      totalTimeout: opts.totalTimeout,\n    });\n    debug(`Next retry delay: ${nextRetryDelay}`);\n\n    if (nextRetryDelay <= 0) {\n      numNoResponseAttempts = opts.noResponseRetries + 1;\n      return;\n    }\n\n    setTimeout(makeRequest, nextRetryDelay);\n  }\n\n  function onResponse(err, response, body) {\n    // An error such as DNS resolution.\n    if (err) {\n      numNoResponseAttempts++;\n\n      if (numNoResponseAttempts <= opts.noResponseRetries) {\n        retryAfterDelay(numNoResponseAttempts);\n      } else {\n        if (streamMode) {\n          retryStream.emit('error', err);\n          retryStream.end();\n        } else {\n          callback(err, response, body);\n        }\n      }\n\n      return;\n    }\n\n    // Send the response to see if we should try again.\n    // NOTE: \"currentRetryAttempt\" isn't accurate by default, as it counts\n    // the very first request sent as the first \"retry\". It is only accurate\n    // when a user provides their own \"currentRetryAttempt\" option at\n    // instantiation.\n    const adjustedCurrentRetryAttempt = manualCurrentRetryAttemptWasSet\n      ? currentRetryAttempt\n      : currentRetryAttempt - 1;\n    if (\n      adjustedCurrentRetryAttempt < opts.retries &&\n      opts.shouldRetryFn(response)\n    ) {\n      retryAfterDelay(currentRetryAttempt);\n      return;\n    }\n\n    // No more attempts need to be made, just continue on.\n    if (streamMode) {\n      retryStream.emit('response', response);\n      delayStream.pipe(retryStream);\n      requestStream.on('error', err => {\n        retryStream.destroy(err);\n      });\n    } else {\n      callback(err, response, body);\n    }\n  }\n}\n\nmodule.exports = retryRequest;\n\nfunction getNextRetryDelay(config) {\n  const {\n    maxRetryDelay,\n    retryDelayMultiplier,\n    retryNumber,\n    timeOfFirstRequest,\n    totalTimeout,\n  } = config;\n\n  const maxRetryDelayMs = maxRetryDelay * 1000;\n  const totalTimeoutMs = totalTimeout * 1000;\n\n  const jitter = Math.floor(Math.random() * 1000);\n  const calculatedNextRetryDelay =\n    Math.pow(retryDelayMultiplier, retryNumber) * 1000 + jitter;\n\n  const maxAllowableDelayMs =\n    totalTimeoutMs - (Date.now() - timeOfFirstRequest);\n\n  return Math.min(\n    calculatedNextRetryDelay,\n    maxAllowableDelayMs,\n    maxRetryDelayMs\n  );\n}\n\nmodule.exports.defaults = DEFAULTS;\nmodule.exports.getNextRetryDelay = getNextRetryDelay;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}